<style>
pre {
  font-size: 10px;
}
</style>
<table border=1><tr valign="top"><td><pre></pre></td><td><pre># `nodes.coffee` contains all of the node classes for the syntax tree. Most
# nodes are created as the result of actions in the [grammar](grammar.html),
# but some are created by other nodes as a method of code generation. To convert
# the syntax tree into a string of JavaScript code, call `compile()` on the root.
</pre></td><td><pre>(function() {
  var Access, Arr, Assign, Base, Block, Call, Class, Closure, Code, Comment, Existenc
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[ke
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); };
    for (var i = 0, l = this.length; i &lt; l; i++) {
      if (this[i] === item) return i;
    }
    return -1;
  };</pre></td></tr><tr valign="top"><td><pre>5,15,Scope</pre></td><td><pre>{Scope} = require './scope'</pre></td><td><pre>  Scope = require('./scope').Scope;</pre></td></tr><tr valign="top"><td><pre>6,16,RESERVED</pre></td><td><pre>{RESERVED} = require './lexer'

# Import the helpers we plan to use.</pre></td><td><pre>  RESERVED = require('./lexer').RESERVED;</pre></td></tr><tr valign="top"><td><pre>9,17,compact</pre></td><td><pre>{compact, flatten, extend, merge, del, starts, ends, last} = require './helpers'

exports.extend = extend  # for parser

# Constant functions for nodes that don't need customization.</pre></td><td><pre>  _ref = require('./helpers'), compact = _ref.compact, flatten = _ref.flatten, extend
  exports.extend = extend;</pre></td></tr><tr valign="top"><td><pre>14,19,YES</pre></td><td><pre>YES     = -&gt; yes
NO      = -&gt; no</pre></td><td><pre>  YES = function() {
    return true;
  };
  NO = function() {
    return false;
  };</pre></td></tr><tr valign="top"><td><pre>16,25,THIS</pre></td><td><pre>THIS    = -&gt; this</pre></td><td><pre>  THIS = function() {
    return this;
  };</pre></td></tr><tr valign="top"><td><pre>17,28,NEGATE</pre></td><td><pre>NEGATE  = -&gt; @negated = not @negated; this

#### Base

# The **Base** is the abstract base class for all nodes in the syntax tree.
# Each subclass implements the `compileNode` method, which performs the
# code generation for that node. To compile a node to JavaScript,
# call `compile` on it, which wraps `compileNode` in some generic extra smarts,
# to know when the generated code needs to be wrapped up in a closure.
# An options hash is passed and cloned throughout, containing information about
# the environment from higher in the tree (such as if a returned value is
# being requested by the surrounding function), information about the current
# scope, and indentation level.</pre></td><td><pre>  NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };</pre></td></tr><tr valign="top"><td><pre>30,32,exports</pre></td><td><pre>exports.Base = class Base

  # Common logic for determining whether to wrap this node in a closure before
  # compiling it, or to compile directly. We need to wrap if this node is a
  # *statement*, and it's not a *pureStatement*, and we're not at
  # the top level of a block (which would be unnecessary), and we haven't
  # already been asked to return the result (because statements know how to
  # return results).</pre></td><td><pre>  exports.Base = Base = (function() {
    function Base() {}</pre></td></tr><tr valign="top"><td><pre>38,34,compile</pre></td><td><pre>  compile: (o, lvl) -&gt;</pre></td><td><pre>    Base.prototype.compile = function(o, lvl) {
      var node;</pre></td></tr><tr valign="top"><td><pre>39,36,extend</pre></td><td><pre>    o        = extend {}, o</pre></td><td><pre>      o = extend({}, o);</pre></td></tr><tr valign="top"><td><pre>40,37,lvl</pre></td><td><pre>    o.level  = lvl if lvl</pre></td><td><pre>      if (lvl) {
        o.level = lvl;
      }</pre></td></tr><tr valign="top"><td><pre>41,40,node</pre></td><td><pre>    node     = @unfoldSoak(o) or this
    node.tab = o.indent</pre></td><td><pre>      node = this.unfoldSoak(o) || this;
      node.tab = o.indent;</pre></td></tr><tr valign="top"><td><pre>43,42,level</pre></td><td><pre>    if o.level is LEVEL_TOP or not node.isStatement(o)
      node.compileNode o
    else</pre></td><td><pre>      if (o.level === LEVEL_TOP || !node.isStatement(o)) {
        return node.compileNode(o);
      } else {</pre></td></tr><tr valign="top"><td><pre>46,45,compileClosure</pre></td><td><pre>      node.compileClosure o

  # Statements converted into expressions via closure-wrapping share a scope
  # object with their parent closure, to preserve the expected lexical scope.
  compileClosure: (o) -&gt;</pre></td><td><pre>        return node.compileClosure(o);
      }
    };
    Base.prototype.compileClosure = function(o) {</pre></td></tr><tr valign="top"><td><pre>51,49,jumps</pre></td><td><pre>    if @jumps() or this instanceof Throw</pre></td><td><pre>      if (this.jumps() || this instanceof Throw) {</pre></td></tr><tr valign="top"><td><pre>52,50,throw</pre></td><td><pre>      throw SyntaxError 'cannot use a pure statement in an expression.'</pre></td><td><pre>        throw SyntaxError('cannot use a pure statement in an expression.');
      }</pre></td></tr><tr valign="top"><td><pre>53,52,sharedScope</pre></td><td><pre>    o.sharedScope = yes</pre></td><td><pre>      o.sharedScope = true;</pre></td></tr><tr valign="top"><td><pre>54,53,Closure</pre></td><td><pre>    Closure.wrap(this).compileNode o

  # If the code generation wishes to use the result of a complex expression
  # in multiple places, ensure that the expression is only ever evaluated once,
  # by assigning it to a temporary variable. Pass a level to precompile.</pre></td><td><pre>      return Closure.wrap(this).compileNode(o);
    };</pre></td></tr><tr valign="top"><td><pre>59,55,cache</pre></td><td><pre>  cache: (o, level, reused) -&gt;</pre></td><td><pre>    Base.prototype.cache = function(o, level, reused) {
      var ref, sub;</pre></td></tr><tr valign="top"><td><pre>60,57,isComplex</pre></td><td><pre>    unless @isComplex()</pre></td><td><pre>      if (!this.isComplex()) {</pre></td></tr><tr valign="top"><td><pre>61,58,ref</pre></td><td><pre>      ref = if level then @compile o, level else this
      [ref, ref]
    else</pre></td><td><pre>        ref = level ? this.compile(o, level) : this;
        return [ref, ref];
      } else {</pre></td></tr><tr valign="top"><td><pre>64,61,new</pre></td><td><pre>      ref = new Literal reused or o.scope.freeVariable 'ref'
      sub = new Assign ref, this</pre></td><td><pre>        ref = new Literal(reused || o.scope.freeVariable('ref'));
        sub = new Assign(ref, this);</pre></td></tr><tr valign="top"><td><pre>66,63,level</pre></td><td><pre>      if level then [sub.compile(o, level), ref.value] else [sub, ref]

  # Compile to a source/variable pair suitable for looping.</pre></td><td><pre>        if (level) {
          return [sub.compile(o, level), ref.value];
        } else {
          return [sub, ref];
        }
      }
    };</pre></td></tr><tr valign="top"><td><pre>69,70,compileLoopReference</pre></td><td><pre>  compileLoopReference: (o, name) -&gt;</pre></td><td><pre>    Base.prototype.compileLoopReference = function(o, name) {
      var src, tmp, _ref2;</pre></td></tr><tr valign="top"><td><pre>70,72,src</pre></td><td><pre>    src = tmp = @compile o, LEVEL_LIST
    unless -Infinity &lt; +src &lt; Infinity or IDENTIFIER.test(src) and o.scope.check(src,
      src = "#{ tmp = o.scope.freeVariable name } = #{src}"
    [src, tmp]

  # Construct a node that returns the current node's result.
  # Note that this is overridden for smarter behavior for
  # many statement nodes (e.g. If, For)...</pre></td><td><pre>      src = tmp = this.compile(o, LEVEL_LIST);
      if (!((-Infinity &lt; (_ref2 = +src) &amp;&amp; _ref2 &lt; Infinity) || IDENTIFIER.test(src) 
        src = "" + (tmp = o.scope.freeVariable(name)) + " = " + src;
      }
      return [src, tmp];
    };</pre></td></tr><tr valign="top"><td><pre>78,78,makeReturn</pre></td><td><pre>  makeReturn: (res) -&gt;</pre></td><td><pre>    Base.prototype.makeReturn = function(res) {
      var me;</pre></td></tr><tr valign="top"><td><pre>79,80,unwrapAll</pre></td><td><pre>    me = @unwrapAll()</pre></td><td><pre>      me = this.unwrapAll();</pre></td></tr><tr valign="top"><td><pre>80,81,res</pre></td><td><pre>    if res</pre></td><td><pre>      if (res) {</pre></td></tr><tr valign="top"><td><pre>81,82,new</pre></td><td><pre>      new Call new Literal("#{res}.push"), [me]
    else
      new Return me

  # Does this node, or any of its children, contain a node of a certain kind?
  # Recursively traverses down the *children* of the nodes, yielding to a block
  # and returning true when the block finds a match. `contains` does not cross
  # scope boundaries.</pre></td><td><pre>        return new Call(new Literal("" + res + ".push"), [me]);
      } else {
        return new Return(me);
      }
    };</pre></td></tr><tr valign="top"><td><pre>89,87,contains</pre></td><td><pre>  contains: (pred) -&gt;
    contains = no</pre></td><td><pre>    Base.prototype.contains = function(pred) {
      var contains;
      contains = false;</pre></td></tr><tr valign="top"><td><pre>91,90,traverseChildren</pre></td><td><pre>    @traverseChildren no, (node) -&gt;
      if pred node</pre></td><td><pre>      this.traverseChildren(false, function(node) {
        if (pred(node)) {</pre></td></tr><tr valign="top"><td><pre>93,92,contains</pre></td><td><pre>        contains = yes
        return no
    contains

  # Is this node of a certain type, or does it contain the type?</pre></td><td><pre>          contains = true;
          return false;
        }
      });
      return contains;
    };</pre></td></tr><tr valign="top"><td><pre>98,98,containsType</pre></td><td><pre>  containsType: (type) -&gt;
    this instanceof type or @contains (node) -&gt; node instanceof type

  # Pull out the last non-comment node of a node list.</pre></td><td><pre>    Base.prototype.containsType = function(type) {
      return this instanceof type || this.contains(function(node) {
        return node instanceof type;
      });
    };</pre></td></tr><tr valign="top"><td><pre>102,103,lastNonComment</pre></td><td><pre>  lastNonComment: (list) -&gt;
    i = list.length</pre></td><td><pre>    Base.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;</pre></td></tr><tr valign="top"><td><pre>104,106,while</pre></td><td><pre>    return list[i] while i-- when list[i] not instanceof Comment
    null

  # `toString` representation of the node, for inspecting the parse tree.
  # This is what `coffee --nodes` prints out.</pre></td><td><pre>      while (i--) {
        if (!(list[i] instanceof Comment)) {
          return list[i];
        }
      }
      return null;
    };</pre></td></tr><tr valign="top"><td><pre>109,113,idt</pre></td><td><pre>  toString: (idt = '', name = @constructor.name) -&gt;</pre></td><td><pre>    Base.prototype.toString = function(idt, name) {
      var lineno, tree;
      if (idt == null) {
        idt = '';
      }
      if (name == null) {
        name = this.constructor.name;
      }</pre></td></tr><tr valign="top"><td><pre>110,121,lineno</pre></td><td><pre>    lineno = if @firstLineNumber
      "#{@firstLineNumber} #{@lastLineNumber - 1} "
    else
      '    '
    tree = '\n' + lineno + idt + name</pre></td><td><pre>      lineno = this.firstLineNumber ? "" + this.firstLineNumber + " " + (this.lastLin
      tree = '\n' + lineno + idt + name;</pre></td></tr><tr valign="top"><td><pre>115,123,soak</pre></td><td><pre>    tree += '?' if @soak</pre></td><td><pre>      if (this.soak) {</pre></td></tr><tr valign="top"><td><pre>116,124,tree</pre></td><td><pre>    @eachChild (node) -&gt; tree += node.toString idt + TAB
    tree

  # Update node w/metadata from Jison (called at parse time)
  # For nodes with children, the base class method does its best to
  # generated first/last line number ranges from its implicit children,
  # but this is less than robust, since its children get built during
  # parse time, and the children aren't necessarily objects.  In practice,
  # many applications may only care about the leaf nodes in the AST.</pre></td><td><pre>        tree += '?';
      }
      this.eachChild(function(node) {
        return tree += node.toString(idt + TAB);
      });
      return tree;
    };</pre></td></tr><tr valign="top"><td><pre>125,131,updateJisonMetadata</pre></td><td><pre>  updateJisonMetadata: (yylineno, lstack, numTokens) -&gt;
    n = lstack.length
    tokens = lstack[(n - numTokens)...n]</pre></td><td><pre>    Base.prototype.updateJisonMetadata = function(yylineno, lstack, numTokens) {
      var n, subnode, tokens, _i, _len, _results;
      n = lstack.length;
      tokens = lstack.slice(n - numTokens, n);
      _results = [];
      for (_i = 0, _len = tokens.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>128,137,subnode</pre></td><td><pre>    for subnode in tokens
      @firstLineNumber ||= subnode.first_line</pre></td><td><pre>        subnode = tokens[_i];
        this.firstLineNumber || (this.firstLineNumber = subnode.first_line);</pre></td></tr><tr valign="top"><td><pre>130,139,lastLineNumber</pre></td><td><pre>      @lastLineNumber = subnode.last_line

  # Passes each child to a function, breaking when the function returns `false`.</pre></td><td><pre>        _results.push(this.lastLineNumber = subnode.last_line);
      }
      return _results;
    };</pre></td></tr><tr valign="top"><td><pre>133,143,eachChild</pre></td><td><pre>  eachChild: (func) -&gt;</pre></td><td><pre>    Base.prototype.eachChild = function(func) {
      var attr, child, _i, _j, _len, _len2, _ref2, _ref3;</pre></td></tr><tr valign="top"><td><pre>134,145,children</pre></td><td><pre>    return this unless @children
    for attr in @children when @[attr]</pre></td><td><pre>      if (!this.children) {
        return this;
      }
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {</pre></td></tr><tr valign="top"><td><pre>136,152,flatten</pre></td><td><pre>      for child in flatten [@[attr]]</pre></td><td><pre>          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len2 = _ref3.length; _j &lt; _len2; _j++) {</pre></td></tr><tr valign="top"><td><pre>137,154,child</pre></td><td><pre>        return this if func(child) is false
    this
</pre></td><td><pre>            child = _ref3[_j];</pre></td></tr><tr valign="top"><td><pre>140,155,func</pre></td><td><pre>  traverseChildren: (crossScope, func) -&gt;
    @eachChild (child) -&gt;
      return false if func(child) is false</pre></td><td><pre>            if (func(child) === false) {
              return this;
            }
          }
        }
      }
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>143,163,traverseChildren</pre></td><td><pre>      child.traverseChildren crossScope, func
</pre></td><td><pre>    Base.prototype.traverseChildren = function(crossScope, func) {
      return this.eachChild(function(child) {
        if (func(child) === false) {
          return false;
        }
        return child.traverseChildren(crossScope, func);
      });
    };</pre></td></tr><tr valign="top"><td><pre>145,171,invert</pre></td><td><pre>  invert: -&gt;</pre></td><td><pre>    Base.prototype.invert = function() {</pre></td></tr><tr valign="top"><td><pre>146,172,new</pre></td><td><pre>    new Op '!', this
</pre></td><td><pre>      return new Op('!', this);
    };</pre></td></tr><tr valign="top"><td><pre>148,174,unwrapAll</pre></td><td><pre>  unwrapAll: -&gt;</pre></td><td><pre>    Base.prototype.unwrapAll = function() {
      var node;</pre></td></tr><tr valign="top"><td><pre>149,176,node</pre></td><td><pre>    node = this
    continue until node is node = node.unwrap()
    node

  # Default implementations of the common node properties and methods. Nodes
  # will override these with custom logic, if needed.</pre></td><td><pre>      node = this;
      while (node !== (node = node.unwrap())) {
        continue;
      }
      return node;
    };</pre></td></tr><tr valign="top"><td><pre>155,182,children</pre></td><td><pre>  children: []
</pre></td><td><pre>    Base.prototype.children = [];</pre></td></tr><tr valign="top"><td><pre>157,183,isStatement</pre></td><td><pre>  isStatement     : NO</pre></td><td><pre>    Base.prototype.isStatement = NO;</pre></td></tr><tr valign="top"><td><pre>158,184,jumps</pre></td><td><pre>  jumps           : NO</pre></td><td><pre>    Base.prototype.jumps = NO;</pre></td></tr><tr valign="top"><td><pre>159,185,isComplex</pre></td><td><pre>  isComplex       : YES</pre></td><td><pre>    Base.prototype.isComplex = YES;</pre></td></tr><tr valign="top"><td><pre>160,186,isChainable</pre></td><td><pre>  isChainable     : NO</pre></td><td><pre>    Base.prototype.isChainable = NO;</pre></td></tr><tr valign="top"><td><pre>161,187,isAssignable</pre></td><td><pre>  isAssignable    : NO
</pre></td><td><pre>    Base.prototype.isAssignable = NO;</pre></td></tr><tr valign="top"><td><pre>163,188,unwrap</pre></td><td><pre>  unwrap     : THIS</pre></td><td><pre>    Base.prototype.unwrap = THIS;</pre></td></tr><tr valign="top"><td><pre>164,189,unfoldSoak</pre></td><td><pre>  unfoldSoak : NO

  # Is this node used to assign a certain variable?</pre></td><td><pre>    Base.prototype.unfoldSoak = NO;</pre></td></tr><tr valign="top"><td><pre>167,190,assigns</pre></td><td><pre>  assigns: NO

#### Block

# The block is the list of expressions that forms the body of an
# indented block of code -- the implementation of a function, a clause in an
# `if`, `switch`, or `try`, and so on...
exports.Block = class Block extends Base</pre></td><td><pre>    Base.prototype.assigns = NO;
    return Base;
  })();
  exports.Block = Block = (function() {
    __extends(Block, Base);</pre></td></tr><tr valign="top"><td><pre>175,195,nodes</pre></td><td><pre>  constructor: (nodes) -&gt;
    @expressions = compact flatten nodes or []
</pre></td><td><pre>    function Block(nodes) {
      this.expressions = compact(flatten(nodes || []));
    }</pre></td></tr><tr valign="top"><td><pre>178,198,children</pre></td><td><pre>  children: ['expressions']

  # Tack an expression on to the end of this expression list.</pre></td><td><pre>    Block.prototype.children = ['expressions'];</pre></td></tr><tr valign="top"><td><pre>181,199,push</pre></td><td><pre>  push: (node) -&gt;
    @expressions.push node
    this

  # Remove and return the last expression of this expression list.</pre></td><td><pre>    Block.prototype.push = function(node) {
      this.expressions.push(node);
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>186,203,pop</pre></td><td><pre>  pop: -&gt;
    @expressions.pop()

  # Add an expression at the beginning of this expression list.</pre></td><td><pre>    Block.prototype.pop = function() {
      return this.expressions.pop();
    };</pre></td></tr><tr valign="top"><td><pre>190,206,unshift</pre></td><td><pre>  unshift: (node) -&gt;
    @expressions.unshift node
    this

  # If this Block consists of just a single node, unwrap it by pulling
  # it back out.</pre></td><td><pre>    Block.prototype.unshift = function(node) {
      this.expressions.unshift(node);
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>196,210,unwrap</pre></td><td><pre>  unwrap: -&gt;</pre></td><td><pre>    Block.prototype.unwrap = function() {</pre></td></tr><tr valign="top"><td><pre>197,211,expressions</pre></td><td><pre>    if @expressions.length is 1 then @expressions[0] else this

  # Is this an empty block of code?</pre></td><td><pre>      if (this.expressions.length === 1) {
        return this.expressions[0];
      } else {
        return this;
      }
    };</pre></td></tr><tr valign="top"><td><pre>200,217,isEmpty</pre></td><td><pre>  isEmpty: -&gt;</pre></td><td><pre>    Block.prototype.isEmpty = function() {</pre></td></tr><tr valign="top"><td><pre>201,218,expressions</pre></td><td><pre>    not @expressions.length
</pre></td><td><pre>      return !this.expressions.length;
    };</pre></td></tr><tr valign="top"><td><pre>203,220,isStatement</pre></td><td><pre>  isStatement: (o) -&gt;
    for exp in @expressions when exp.isStatement o
      return yes
    no
</pre></td><td><pre>    Block.prototype.isStatement = function(o) {
      var exp, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        exp = _ref2[_i];
        if (exp.isStatement(o)) {
          return true;
        }
      }
      return false;
    };</pre></td></tr><tr valign="top"><td><pre>208,231,jumps</pre></td><td><pre>  jumps: (o) -&gt;</pre></td><td><pre>    Block.prototype.jumps = function(o) {
      var exp, _i, _len, _ref2;</pre></td></tr><tr valign="top"><td><pre>209,233,expressions</pre></td><td><pre>    for exp in @expressions</pre></td><td><pre>      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>210,235,exp</pre></td><td><pre>      return exp if exp.jumps o

  # A Block node does not return its entire body, rather it
  # ensures that the final expression is returned.</pre></td><td><pre>        exp = _ref2[_i];
        if (exp.jumps(o)) {
          return exp;
        }
      }
    };</pre></td></tr><tr valign="top"><td><pre>214,241,makeReturn</pre></td><td><pre>  makeReturn: (res) -&gt;</pre></td><td><pre>    Block.prototype.makeReturn = function(res) {
      var expr, len;</pre></td></tr><tr valign="top"><td><pre>215,243,len</pre></td><td><pre>    len = @expressions.length
    while len--
      expr = @expressions[len]</pre></td><td><pre>      len = this.expressions.length;
      while (len--) {
        expr = this.expressions[len];</pre></td></tr><tr valign="top"><td><pre>218,246,instanceof</pre></td><td><pre>      if expr not instanceof Comment
        @expressions[len] = expr.makeReturn res
        @expressions.splice(len, 1) if expr instanceof Return and not expr.expression</pre></td><td><pre>        if (!(expr instanceof Comment)) {
          this.expressions[len] = expr.makeReturn(res);
          if (expr instanceof Return &amp;&amp; !expr.expression) {
            this.expressions.splice(len, 1);
          }</pre></td></tr><tr valign="top"><td><pre>221,251,break</pre></td><td><pre>        break
    this

  # A **Block** is the only node that can serve as the root.</pre></td><td><pre>          break;
        }
      }
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>225,256,compile</pre></td><td><pre>  compile: (o = {}, level) -&gt;
    if o.scope then super o, level else @compileRoot o

  # Compile all expressions within the **Block** body. If we need to
  # return the result, and it's an expression, simply return it. If it's a
  # statement, ask the statement to do so.</pre></td><td><pre>    Block.prototype.compile = function(o, level) {
      if (o == null) {
        o = {};
      }
      if (o.scope) {
        return Block.__super__.compile.call(this, o, level);
      } else {
        return this.compileRoot(o);
      }
    };</pre></td></tr><tr valign="top"><td><pre>231,266,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Block.prototype.compileNode = function(o) {
      var code, codes, node, top, _i, _len, _ref2;</pre></td></tr><tr valign="top"><td><pre>232,268,tab</pre></td><td><pre>    @tab  = o.indent</pre></td><td><pre>      this.tab = o.indent;</pre></td></tr><tr valign="top"><td><pre>233,269,top</pre></td><td><pre>    top   = o.level is LEVEL_TOP</pre></td><td><pre>      top = o.level === LEVEL_TOP;</pre></td></tr><tr valign="top"><td><pre>234,270,codes</pre></td><td><pre>    codes = []</pre></td><td><pre>      codes = [];</pre></td></tr><tr valign="top"><td><pre>235,271,expressions</pre></td><td><pre>    for node in @expressions</pre></td><td><pre>      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>236,273,node</pre></td><td><pre>      node = node.unwrapAll()
      node = (node.unfoldSoak(o) or node)</pre></td><td><pre>        node = _ref2[_i];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;</pre></td></tr><tr valign="top"><td><pre>238,276,instanceof</pre></td><td><pre>      if node instanceof Block
        # This is a nested block.  We don't do anything special here like enclose
        # it in a new scope; we just compile the statements in this block along with
        # our own
        codes.push node.compileNode o</pre></td><td><pre>        if (node instanceof Block) {
          codes.push(node.compileNode(o));</pre></td></tr><tr valign="top"><td><pre>243,278,top</pre></td><td><pre>      else if top</pre></td><td><pre>        } else if (top) {</pre></td></tr><tr valign="top"><td><pre>244,279,node</pre></td><td><pre>        node.front = true
        code = node.compile o</pre></td><td><pre>          node.front = true;
          code = node.compile(o);</pre></td></tr><tr valign="top"><td><pre>246,281,codes</pre></td><td><pre>        codes.push if node.isStatement o then code else "#{@tab}#{code};"
      else
        codes.push node.compile o, LEVEL_LIST</pre></td><td><pre>          codes.push(node.isStatement(o) ? code : "" + this.tab + code + ";");
        } else {
          codes.push(node.compile(o, LEVEL_LIST));
        }
      }</pre></td></tr><tr valign="top"><td><pre>249,286,top</pre></td><td><pre>    if top</pre></td><td><pre>      if (top) {</pre></td></tr><tr valign="top"><td><pre>250,287,spaced</pre></td><td><pre>      if @spaced</pre></td><td><pre>        if (this.spaced) {</pre></td></tr><tr valign="top"><td><pre>251,288,codes</pre></td><td><pre>        return '\n' + codes.join('\n\n') + '\n'
      else
        return codes.join '\n'</pre></td><td><pre>          return '\n' + codes.join('\n\n') + '\n';
        } else {
          return codes.join('\n');
        }
      }</pre></td></tr><tr valign="top"><td><pre>254,293,code</pre></td><td><pre>    code = codes.join(', ') or 'void 0'
    if codes.length &gt; 1 and o.level &gt;= LEVEL_LIST then "(#{code})" else code

  # If we happen to be the top-level **Block**, wrap everything in
  # a safety closure, unless requested not to.
  # It would be better not to generate them in the first place, but for now,
  # clean up obvious double-parentheses.</pre></td><td><pre>      code = codes.join(', ') || 'void 0';
      if (codes.length &gt; 1 &amp;&amp; o.level &gt;= LEVEL_LIST) {
        return "(" + code + ")";
      } else {
        return code;
      }
    };</pre></td></tr><tr valign="top"><td><pre>261,300,compileRoot</pre></td><td><pre>  compileRoot: (o) -&gt;</pre></td><td><pre>    Block.prototype.compileRoot = function(o) {
      var code;</pre></td></tr><tr valign="top"><td><pre>262,302,indent</pre></td><td><pre>    o.indent = @tab = if o.bare then '' else TAB</pre></td><td><pre>      o.indent = this.tab = o.bare ? '' : TAB;</pre></td></tr><tr valign="top"><td><pre>263,303,scope</pre></td><td><pre>    o.scope  = new Scope null, this, null</pre></td><td><pre>      o.scope = new Scope(null, this, null);</pre></td></tr><tr valign="top"><td><pre>264,304,level</pre></td><td><pre>    o.level  = LEVEL_TOP</pre></td><td><pre>      o.level = LEVEL_TOP;</pre></td></tr><tr valign="top"><td><pre>265,305,spaced</pre></td><td><pre>    @spaced  = yes</pre></td><td><pre>      this.spaced = true;</pre></td></tr><tr valign="top"><td><pre>266,306,code</pre></td><td><pre>    code     = @compileWithDeclarations o
    if o.bare then code else "(function() {\n#{code}\n}).call(this);\n"

  # Compile the expressions body for the contents of a function, with
  # declarations of all inner variables pushed up to the top.
  compileWithDeclarations: (o) -&gt;</pre></td><td><pre>      code = this.compileWithDeclarations(o);
      if (o.bare) {
        return code;
      } else {
        return "(function() {\n" + code + "\n}).call(this);\n";
      }
    };
    Block.prototype.compileWithDeclarations = function(o) {
      var assigns, code, declars, exp, i, post, rest, scope, _len, _ref2;</pre></td></tr><tr valign="top"><td><pre>272,315,post</pre></td><td><pre>    code = post = ''</pre></td><td><pre>      code = post = '';</pre></td></tr><tr valign="top"><td><pre>273,316,expressions</pre></td><td><pre>    for exp, i in @expressions</pre></td><td><pre>      _ref2 = this.expressions;
      for (i = 0, _len = _ref2.length; i &lt; _len; i++) {</pre></td></tr><tr valign="top"><td><pre>274,318,exp</pre></td><td><pre>      exp = exp.unwrap()
      break unless exp instanceof Comment or exp instanceof Literal</pre></td><td><pre>        exp = _ref2[i];
        exp = exp.unwrap();
        if (!(exp instanceof Comment || exp instanceof Literal)) {
          break;
        }
      }</pre></td></tr><tr valign="top"><td><pre>276,324,merge</pre></td><td><pre>    o = merge(o, level: LEVEL_TOP)
    if i</pre></td><td><pre>      o = merge(o, {
        level: LEVEL_TOP
      });
      if (i) {</pre></td></tr><tr valign="top"><td><pre>278,328,rest</pre></td><td><pre>      rest = @expressions.splice i, @expressions.length</pre></td><td><pre>        rest = this.expressions.splice(i, this.expressions.length);</pre></td></tr><tr valign="top"><td><pre>279,329,code</pre></td><td><pre>      code = @compileNode(o)</pre></td><td><pre>        code = this.compileNode(o);</pre></td></tr><tr valign="top"><td><pre>280,330,expressions</pre></td><td><pre>      @expressions = rest</pre></td><td><pre>        this.expressions = rest;
      }</pre></td></tr><tr valign="top"><td><pre>281,332,post</pre></td><td><pre>    post = @compileNode o</pre></td><td><pre>      post = this.compileNode(o);</pre></td></tr><tr valign="top"><td><pre>282,333,scope</pre></td><td><pre>    {scope} = o
    if scope.expressions is this</pre></td><td><pre>      scope = o.scope;
      if (scope.expressions === this) {</pre></td></tr><tr valign="top"><td><pre>284,335,declars</pre></td><td><pre>      declars = o.scope.hasDeclarations()
      assigns = scope.hasAssignments
      if (declars or assigns) and i</pre></td><td><pre>        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        if ((declars || assigns) &amp;&amp; i) {</pre></td></tr><tr valign="top"><td><pre>287,338,code</pre></td><td><pre>        code += '\n'</pre></td><td><pre>          code += '\n';
        }</pre></td></tr><tr valign="top"><td><pre>288,340,declars</pre></td><td><pre>      if declars</pre></td><td><pre>        if (declars) {</pre></td></tr><tr valign="top"><td><pre>289,341,code</pre></td><td><pre>        code += "#{@tab}var #{ scope.declaredVariables().join(', ') };\n"</pre></td><td><pre>          code += "" + this.tab + "var " + (scope.declaredVariables().join(', ')) + "
        }</pre></td></tr><tr valign="top"><td><pre>290,343,assigns</pre></td><td><pre>      if assigns</pre></td><td><pre>        if (assigns) {</pre></td></tr><tr valign="top"><td><pre>291,344,code</pre></td><td><pre>        code += "#{@tab}var #{ multident scope.assignedVariables().join(', '), @tab }
    code + post

  # Wrap up the given nodes as a **Block**, unless it already happens
  # to be one.</pre></td><td><pre>          code += "" + this.tab + "var " + (multident(scope.assignedVariables().join(
        }
      }
      return code + post;
    };</pre></td></tr><tr valign="top"><td><pre>296,349,wrap</pre></td><td><pre>  @wrap: (nodes) -&gt;
    return nodes[0] if nodes.length is 1 and nodes[0] instanceof Block</pre></td><td><pre>    Block.wrap = function(nodes) {
      if (nodes.length === 1 &amp;&amp; nodes[0] instanceof Block) {
        return nodes[0];
      }</pre></td></tr><tr valign="top"><td><pre>298,353,new</pre></td><td><pre>    new Block nodes

#### Literal

# Literals are static values that can be passed through directly into
# JavaScript without translation, such as: strings, numbers,
# `true`, `false`, `null`...</pre></td><td><pre>      return new Block(nodes);
    };
    return Block;
  })();</pre></td></tr><tr valign="top"><td><pre>305,357,exports</pre></td><td><pre>exports.Literal = class Literal extends Base</pre></td><td><pre>  exports.Literal = Literal = (function() {
    __extends(Literal, Base);</pre></td></tr><tr valign="top"><td><pre>306,359,value</pre></td><td><pre>  constructor: (@value) -&gt;
</pre></td><td><pre>    function Literal(value) {
      this.value = value;
    }</pre></td></tr><tr valign="top"><td><pre>308,362,makeReturn</pre></td><td><pre>  makeReturn: -&gt;</pre></td><td><pre>    Literal.prototype.makeReturn = function() {</pre></td></tr><tr valign="top"><td><pre>309,363,isStatement</pre></td><td><pre>    if @isStatement() then this else super
</pre></td><td><pre>      if (this.isStatement()) {
        return this;
      } else {
        return Literal.__super__.makeReturn.apply(this, arguments);
      }
    };</pre></td></tr><tr valign="top"><td><pre>311,369,isAssignable</pre></td><td><pre>  isAssignable: -&gt;</pre></td><td><pre>    Literal.prototype.isAssignable = function() {</pre></td></tr><tr valign="top"><td><pre>312,370,IDENTIFIER</pre></td><td><pre>    IDENTIFIER.test @value
</pre></td><td><pre>      return IDENTIFIER.test(this.value);
    };</pre></td></tr><tr valign="top"><td><pre>314,372,isStatement</pre></td><td><pre>  isStatement: -&gt;</pre></td><td><pre>    Literal.prototype.isStatement = function() {
      var _ref2;</pre></td></tr><tr valign="top"><td><pre>315,374,value</pre></td><td><pre>    @value in ['break', 'continue', 'debugger']
</pre></td><td><pre>      return (_ref2 = this.value) === 'break' || _ref2 === 'continue' || _ref2 === 'd
    };</pre></td></tr><tr valign="top"><td><pre>317,376,isComplex</pre></td><td><pre>  isComplex: NO
</pre></td><td><pre>    Literal.prototype.isComplex = NO;</pre></td></tr><tr valign="top"><td><pre>319,377,assigns</pre></td><td><pre>  assigns: (name) -&gt;
    name is @value
</pre></td><td><pre>    Literal.prototype.assigns = function(name) {
      return name === this.value;
    };</pre></td></tr><tr valign="top"><td><pre>322,380,jumps</pre></td><td><pre>  jumps: (o) -&gt;</pre></td><td><pre>    Literal.prototype.jumps = function(o) {</pre></td></tr><tr valign="top"><td><pre>323,381,isStatement</pre></td><td><pre>    return no unless @isStatement()</pre></td><td><pre>      if (!this.isStatement()) {
        return false;
      }</pre></td></tr><tr valign="top"><td><pre>324,384,block</pre></td><td><pre>    if not (o and (o.loop or o.block and (@value isnt 'continue'))) then this else no
</pre></td><td><pre>      if (!(o &amp;&amp; (o.loop || o.block &amp;&amp; (this.value !== 'continue')))) {
        return this;
      } else {
        return false;
      }
    };</pre></td></tr><tr valign="top"><td><pre>326,390,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Literal.prototype.compileNode = function(o) {
      var code, _ref2, _ref3;</pre></td></tr><tr valign="top"><td><pre>327,392,code</pre></td><td><pre>    code = if @isUndefined
      if o.level &gt;= LEVEL_ACCESS then '(void 0)' else 'void 0'
    else if @value is 'this'
      if o.scope.method?.bound then o.scope.method.context else @value
    else if @value.reserved and "#{@value}" not in ['eval', 'arguments']
      "\"#{@value}\""
    else
      @value</pre></td><td><pre>      code = this.isUndefined ? o.level &gt;= LEVEL_ACCESS ? '(void 0)' : 'void 0' : thi</pre></td></tr><tr valign="top"><td><pre>335,393,isStatement</pre></td><td><pre>    if @isStatement() then "#{@tab}#{code};" else code

  toString: -&gt;</pre></td><td><pre>      if (this.isStatement()) {
        return "" + this.tab + code + ";";
      } else {
        return code;
      }
    };
    Literal.prototype.toString = function() {</pre></td></tr><tr valign="top"><td><pre>338,400,value</pre></td><td><pre>    ' "' + @value + '"'

#### Return

# A `return` is a *pureStatement* -- wrapping it in a closure wouldn't
# make sense.</pre></td><td><pre>      return ' "' + this.value + '"';
    };
    return Literal;
  })();</pre></td></tr><tr valign="top"><td><pre>344,404,exports</pre></td><td><pre>exports.Return = class Return extends Base</pre></td><td><pre>  exports.Return = Return = (function() {
    __extends(Return, Base);</pre></td></tr><tr valign="top"><td><pre>345,406,expr</pre></td><td><pre>  constructor: (expr) -&gt;
    @expression = expr if expr and not expr.unwrap().isUndefined
</pre></td><td><pre>    function Return(expr) {
      if (expr &amp;&amp; !expr.unwrap().isUndefined) {
        this.expression = expr;
      }
    }</pre></td></tr><tr valign="top"><td><pre>348,411,children</pre></td><td><pre>  children: ['expression']
</pre></td><td><pre>    Return.prototype.children = ['expression'];</pre></td></tr><tr valign="top"><td><pre>350,412,isStatement</pre></td><td><pre>  isStatement:     YES</pre></td><td><pre>    Return.prototype.isStatement = YES;</pre></td></tr><tr valign="top"><td><pre>351,413,makeReturn</pre></td><td><pre>  makeReturn:      THIS
  jumps:           THIS
</pre></td><td><pre>    Return.prototype.makeReturn = THIS;
    Return.prototype.jumps = THIS;</pre></td></tr><tr valign="top"><td><pre>354,415,compile</pre></td><td><pre>  compile: (o, level) -&gt;</pre></td><td><pre>    Return.prototype.compile = function(o, level) {
      var expr, _ref2;</pre></td></tr><tr valign="top"><td><pre>355,417,expr</pre></td><td><pre>    expr = @expression?.makeReturn()
    if expr and expr not instanceof Return then expr.compile o, level else super o, l
</pre></td><td><pre>      expr = (_ref2 = this.expression) != null ? _ref2.makeReturn() : void 0;
      if (expr &amp;&amp; !(expr instanceof Return)) {
        return expr.compile(o, level);
      } else {
        return Return.__super__.compile.call(this, o, level);
      }
    };</pre></td></tr><tr valign="top"><td><pre>358,424,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Return.prototype.compileNode = function(o) {</pre></td></tr><tr valign="top"><td><pre>359,425,tab</pre></td><td><pre>    @tab + "return#{[" #{@expression.compile o, LEVEL_PAREN}" if @expression]};"

#### Value

# A value, variable or literal or parenthesized, indexed or dotted into,
# or vanilla.</pre></td><td><pre>      return this.tab + ("return" + [this.expression ? " " + (this.expression.compile
    };
    return Return;
  })();</pre></td></tr><tr valign="top"><td><pre>365,429,exports</pre></td><td><pre>exports.Value = class Value extends Base</pre></td><td><pre>  exports.Value = Value = (function() {
    __extends(Value, Base);</pre></td></tr><tr valign="top"><td><pre>366,431,base</pre></td><td><pre>  constructor: (base, props, tag) -&gt;
    return base if not props and base instanceof Value
    @base       = base</pre></td><td><pre>    function Value(base, props, tag) {
      if (!props &amp;&amp; base instanceof Value) {
        return base;
      }
      this.base = base;</pre></td></tr><tr valign="top"><td><pre>369,436,properties</pre></td><td><pre>    @properties = props or []</pre></td><td><pre>      this.properties = props || [];</pre></td></tr><tr valign="top"><td><pre>370,437,tag</pre></td><td><pre>    @[tag]      = true if tag
    return this
</pre></td><td><pre>      if (tag) {
        this[tag] = true;
      }
      return this;
    }</pre></td></tr><tr valign="top"><td><pre>373,442,children</pre></td><td><pre>  children: ['base', 'properties']

  # Add a property (or *properties* ) `Access` to the list.</pre></td><td><pre>    Value.prototype.children = ['base', 'properties'];</pre></td></tr><tr valign="top"><td><pre>376,443,add</pre></td><td><pre>  add: (props) -&gt;
    @properties = @properties.concat props
    this
</pre></td><td><pre>    Value.prototype.add = function(props) {
      this.properties = this.properties.concat(props);
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>380,447,hasProperties</pre></td><td><pre>  hasProperties: -&gt;</pre></td><td><pre>    Value.prototype.hasProperties = function() {</pre></td></tr><tr valign="top"><td><pre>381,448,properties</pre></td><td><pre>    !!@properties.length

  # Some boolean checks for the benefit of other nodes.
  isArray        : -&gt; not @properties.length and @base instanceof Arr</pre></td><td><pre>      return !!this.properties.length;
    };
    Value.prototype.isArray = function() {
      return !this.properties.length &amp;&amp; this.base instanceof Arr;
    };</pre></td></tr><tr valign="top"><td><pre>385,453,isComplex</pre></td><td><pre>  isComplex      : -&gt; @hasProperties() or @base.isComplex()</pre></td><td><pre>    Value.prototype.isComplex = function() {</pre></td></tr><tr valign="top"><td><pre>386,454,hasProperties</pre></td><td><pre>  isAssignable   : -&gt; @hasProperties() or @base.isAssignable()
  isSimpleNumber : -&gt; @base instanceof Literal and SIMPLENUM.test @base.value</pre></td><td><pre>      return this.hasProperties() || this.base.isComplex();
    };
    Value.prototype.isAssignable = function() {
      return this.hasProperties() || this.base.isAssignable();
    };
    Value.prototype.isSimpleNumber = function() {
      return this.base instanceof Literal &amp;&amp; SIMPLENUM.test(this.base.value);
    };</pre></td></tr><tr valign="top"><td><pre>388,462,isAtomic</pre></td><td><pre>  isAtomic       : -&gt;</pre></td><td><pre>    Value.prototype.isAtomic = function() {
      var node, _i, _len, _ref2;</pre></td></tr><tr valign="top"><td><pre>389,464,properties</pre></td><td><pre>    for node in @properties.concat @base</pre></td><td><pre>      _ref2 = this.properties.concat(this.base);
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>390,466,node</pre></td><td><pre>      return no if node.soak or node instanceof Call
    yes
</pre></td><td><pre>        node = _ref2[_i];
        if (node.soak || node instanceof Call) {
          return false;
        }
      }
      return true;
    };</pre></td></tr><tr valign="top"><td><pre>393,473,isStatement</pre></td><td><pre>  isStatement : (o)    -&gt; not @properties.length and @base.isStatement o</pre></td><td><pre>    Value.prototype.isStatement = function(o) {</pre></td></tr><tr valign="top"><td><pre>394,474,properties</pre></td><td><pre>  assigns     : (name) -&gt; not @properties.length and @base.assigns name
  jumps       : (o)    -&gt; not @properties.length and @base.jumps o
</pre></td><td><pre>      return !this.properties.length &amp;&amp; this.base.isStatement(o);
    };
    Value.prototype.assigns = function(name) {
      return !this.properties.length &amp;&amp; this.base.assigns(name);
    };
    Value.prototype.jumps = function(o) {
      return !this.properties.length &amp;&amp; this.base.jumps(o);
    };</pre></td></tr><tr valign="top"><td><pre>397,482,isObject</pre></td><td><pre>  isObject: (onlyGenerated) -&gt;</pre></td><td><pre>    Value.prototype.isObject = function(onlyGenerated) {</pre></td></tr><tr valign="top"><td><pre>398,483,properties</pre></td><td><pre>    return no if @properties.length</pre></td><td><pre>      if (this.properties.length) {
        return false;
      }</pre></td></tr><tr valign="top"><td><pre>399,486,base</pre></td><td><pre>    (@base instanceof Obj) and (not onlyGenerated or @base.generated)
</pre></td><td><pre>      return (this.base instanceof Obj) &amp;&amp; (!onlyGenerated || this.base.generated);
    };</pre></td></tr><tr valign="top"><td><pre>401,488,isSplice</pre></td><td><pre>  isSplice: -&gt;</pre></td><td><pre>    Value.prototype.isSplice = function() {</pre></td></tr><tr valign="top"><td><pre>402,489,last</pre></td><td><pre>    last(@properties) instanceof Slice

  # The value can be unwrapped as its inner node, if there are no attached
  # properties.</pre></td><td><pre>      return last(this.properties) instanceof Slice;
    };</pre></td></tr><tr valign="top"><td><pre>406,491,unwrap</pre></td><td><pre>  unwrap: -&gt;</pre></td><td><pre>    Value.prototype.unwrap = function() {</pre></td></tr><tr valign="top"><td><pre>407,492,properties</pre></td><td><pre>    if @properties.length then this else @base

  # A reference has base part (`this` value) and name part.
  # We cache them separately for compiling complex expressions.
  # `a()[b()] ?= c` -&gt; `(_base = a())[_name = b()] ? _base[_name] = c`</pre></td><td><pre>      if (this.properties.length) {
        return this;
      } else {
        return this.base;
      }
    };</pre></td></tr><tr valign="top"><td><pre>412,498,cacheReference</pre></td><td><pre>  cacheReference: (o) -&gt;</pre></td><td><pre>    Value.prototype.cacheReference = function(o) {
      var base, bref, name, nref;</pre></td></tr><tr valign="top"><td><pre>413,500,name</pre></td><td><pre>    name = last @properties
    if @properties.length &lt; 2 and not @base.isComplex() and not name?.isComplex()
      return [this, this]  # `a` `a.b`</pre></td><td><pre>      name = last(this.properties);
      if (this.properties.length &lt; 2 &amp;&amp; !this.base.isComplex() &amp;&amp; !(name != null ? na
        return [this, this];
      }</pre></td></tr><tr valign="top"><td><pre>416,504,new</pre></td><td><pre>    base = new Value @base, @properties[...-1]
    if base.isComplex()  # `a().b`
      bref = new Literal o.scope.freeVariable 'base'
      base = new Value new Parens new Assign bref, base</pre></td><td><pre>      base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) {
        bref = new Literal(o.scope.freeVariable('base'));
        base = new Value(new Parens(new Assign(bref, base)));
      }</pre></td></tr><tr valign="top"><td><pre>420,509,name</pre></td><td><pre>    return [base, bref] unless name  # `a()`
    if name.isComplex()  # `a[b()]`</pre></td><td><pre>      if (!name) {
        return [base, bref];
      }
      if (name.isComplex()) {</pre></td></tr><tr valign="top"><td><pre>422,513,nref</pre></td><td><pre>      nref = new Literal o.scope.freeVariable 'name'
      name = new Index new Assign nref, name.index
      nref = new Index nref</pre></td><td><pre>        nref = new Literal(o.scope.freeVariable('name'));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
      }</pre></td></tr><tr valign="top"><td><pre>425,517,base</pre></td><td><pre>    [base.add(name), new Value(bref or base.base, [nref or name])]

  # We compile a value to JavaScript by compiling and joining each property.
  # Things get much more interesting if the chain of properties has *soak*
  # operators `?.` interspersed. Then we have to take care not to accidentally
  # evaluate anything twice when building the soak chain.</pre></td><td><pre>      return [base.add(name), new Value(bref || base.base, [nref || name])];
    };</pre></td></tr><tr valign="top"><td><pre>431,519,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Value.prototype.compileNode = function(o) {
      var code, prop, props, _i, _len;</pre></td></tr><tr valign="top"><td><pre>432,521,base</pre></td><td><pre>    @base.front = @front</pre></td><td><pre>      this.base.front = this.front;</pre></td></tr><tr valign="top"><td><pre>433,522,props</pre></td><td><pre>    props = @properties
    code  = @base.compile o, if props.length then LEVEL_ACCESS else null
    code  = "#{code}." if (@base instanceof Parens or props.length) and SIMPLENUM.tes</pre></td><td><pre>      props = this.properties;
      code = this.base.compile(o, props.length ? LEVEL_ACCESS : null);
      if ((this.base instanceof Parens || props.length) &amp;&amp; SIMPLENUM.test(code)) {
        code = "" + code + ".";
      }
      for (_i = 0, _len = props.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>436,528,prop</pre></td><td><pre>    code += prop.compile o for prop in props</pre></td><td><pre>        prop = props[_i];</pre></td></tr><tr valign="top"><td><pre>437,529,code</pre></td><td><pre>    code

  # Unfold a soak into an `If`: `a?.b` -&gt; `a.b if a?`</pre></td><td><pre>        code += prop.compile(o);
      }
      return code;
    };</pre></td></tr><tr valign="top"><td><pre>440,533,unfoldSoak</pre></td><td><pre>  unfoldSoak: (o) -&gt;</pre></td><td><pre>    Value.prototype.unfoldSoak = function(o) {
      var result;</pre></td></tr><tr valign="top"><td><pre>441,535,unfoldedSoak</pre></td><td><pre>    return @unfoldedSoak if @unfoldedSoak?</pre></td><td><pre>      if (this.unfoldedSoak != null) {
        return this.unfoldedSoak;
      }</pre></td></tr><tr valign="top"><td><pre>442,538,result</pre></td><td><pre>    result = do =&gt;</pre></td><td><pre>      result = __bind(function() {
        var fst, i, ifn, prop, ref, snd, _len, _ref2;</pre></td></tr><tr valign="top"><td><pre>443,540,ifn</pre></td><td><pre>      if ifn = @base.unfoldSoak o
        Array::push.apply ifn.body.properties, @properties
        return ifn</pre></td><td><pre>        if (ifn = this.base.unfoldSoak(o)) {
          Array.prototype.push.apply(ifn.body.properties, this.properties);
          return ifn;
        }
        _ref2 = this.properties;
        for (i = 0, _len = _ref2.length; i &lt; _len; i++) {</pre></td></tr><tr valign="top"><td><pre>446,546,prop</pre></td><td><pre>      for prop, i in @properties when prop.soak
        prop.soak = off</pre></td><td><pre>          prop = _ref2[i];
          if (prop.soak) {
            prop.soak = false;</pre></td></tr><tr valign="top"><td><pre>448,549,fst</pre></td><td><pre>        fst = new Value @base, @properties[...i]
        snd = new Value @base, @properties[i..]
        if fst.isComplex()</pre></td><td><pre>            fst = new Value(this.base, this.properties.slice(0, i));
            snd = new Value(this.base, this.properties.slice(i));
            if (fst.isComplex()) {</pre></td></tr><tr valign="top"><td><pre>451,552,ref</pre></td><td><pre>          ref = new Literal o.scope.freeVariable 'ref'
          fst = new Parens new Assign ref, fst</pre></td><td><pre>              ref = new Literal(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));</pre></td></tr><tr valign="top"><td><pre>453,554,snd</pre></td><td><pre>          snd.base = ref
        return new If new Existence(fst), snd, soak: on
      null</pre></td><td><pre>              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
        }
        return null;
      }, this)();</pre></td></tr><tr valign="top"><td><pre>456,563,unfoldedSoak</pre></td><td><pre>    @unfoldedSoak = result or no

#### Comment

# CoffeeScript passes through block comments as JavaScript block comments
# at the same position.</pre></td><td><pre>      return this.unfoldedSoak = result || false;
    };
    return Value;
  })();</pre></td></tr><tr valign="top"><td><pre>462,567,exports</pre></td><td><pre>exports.Comment = class Comment extends Base</pre></td><td><pre>  exports.Comment = Comment = (function() {
    __extends(Comment, Base);</pre></td></tr><tr valign="top"><td><pre>463,569,comment</pre></td><td><pre>  constructor: (@comment) -&gt;
</pre></td><td><pre>    function Comment(comment) {
      this.comment = comment;
    }</pre></td></tr><tr valign="top"><td><pre>465,572,isStatement</pre></td><td><pre>  isStatement:     YES</pre></td><td><pre>    Comment.prototype.isStatement = YES;</pre></td></tr><tr valign="top"><td><pre>466,573,makeReturn</pre></td><td><pre>  makeReturn:      THIS
</pre></td><td><pre>    Comment.prototype.makeReturn = THIS;</pre></td></tr><tr valign="top"><td><pre>468,574,compileNode</pre></td><td><pre>  compileNode: (o, level) -&gt;</pre></td><td><pre>    Comment.prototype.compileNode = function(o, level) {
      var code;</pre></td></tr><tr valign="top"><td><pre>469,576,code</pre></td><td><pre>    code = '/*' + multident(@comment, @tab) + "\n#{@tab}*/"
    code = o.indent + code if (level or o.level) is LEVEL_TOP
    code

#### Call

# Node for a function invocation. Takes care of converting `super()` calls into
# calls against the prototype's function of the same name.</pre></td><td><pre>      code = '/*' + multident(this.comment, this.tab) + ("\n" + this.tab + "*/");
      if ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      return code;
    };
    return Comment;
  })();</pre></td></tr><tr valign="top"><td><pre>477,584,exports</pre></td><td><pre>exports.Call = class Call extends Base</pre></td><td><pre>  exports.Call = Call = (function() {
    __extends(Call, Base);</pre></td></tr><tr valign="top"><td><pre>478,586,variable</pre></td><td><pre>  constructor: (variable, @args = [], @soak) -&gt;</pre></td><td><pre>    function Call(variable, args, soak) {
      this.args = args != null ? args : [];
      this.soak = soak;</pre></td></tr><tr valign="top"><td><pre>479,589,isNew</pre></td><td><pre>    @isNew    = false</pre></td><td><pre>      this.isNew = false;</pre></td></tr><tr valign="top"><td><pre>480,590,isSuper</pre></td><td><pre>    @isSuper  = variable is 'super'
    @variable = if @isSuper then null else variable
</pre></td><td><pre>      this.isSuper = variable === 'super';
      this.variable = this.isSuper ? null : variable;
    }</pre></td></tr><tr valign="top"><td><pre>483,593,children</pre></td><td><pre>  children: ['variable', 'args']

  # Tag this invocation as creating a new instance.</pre></td><td><pre>    Call.prototype.children = ['variable', 'args'];</pre></td></tr><tr valign="top"><td><pre>486,594,newInstance</pre></td><td><pre>  newInstance: -&gt;</pre></td><td><pre>    Call.prototype.newInstance = function() {
      var base, _ref2;</pre></td></tr><tr valign="top"><td><pre>487,596,base</pre></td><td><pre>    base = @variable?.base or @variable
    if base instanceof Call and not base.isNew</pre></td><td><pre>      base = ((_ref2 = this.variable) != null ? _ref2.base : void 0) || this.variable
      if (base instanceof Call &amp;&amp; !base.isNew) {</pre></td></tr><tr valign="top"><td><pre>489,598,newInstance</pre></td><td><pre>      base.newInstance()
    else</pre></td><td><pre>        base.newInstance();
      } else {</pre></td></tr><tr valign="top"><td><pre>491,600,isNew</pre></td><td><pre>      @isNew = true
    this

  # Grab the reference to the superclass's implementation of the current
  # method.</pre></td><td><pre>        this.isNew = true;
      }
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>496,604,superReference</pre></td><td><pre>  superReference: (o) -&gt;</pre></td><td><pre>    Call.prototype.superReference = function(o) {
      var accesses, method, name;</pre></td></tr><tr valign="top"><td><pre>497,606,method</pre></td><td><pre>    {method} = o.scope
    throw SyntaxError 'cannot call super outside of a function.' unless method</pre></td><td><pre>      method = o.scope.method;
      if (!method) {
        throw SyntaxError('cannot call super outside of a function.');
      }</pre></td></tr><tr valign="top"><td><pre>499,610,name</pre></td><td><pre>    {name} = method
    throw SyntaxError 'cannot call super on an anonymous function.' unless name?
    if method.klass</pre></td><td><pre>      name = method.name;
      if (name == null) {
        throw SyntaxError('cannot call super on an anonymous function.');
      }
      if (method.klass) {</pre></td></tr><tr valign="top"><td><pre>502,615,accesses</pre></td><td><pre>      accesses = [new Access(new Literal '__super__')]
      accesses.push new Access new Literal 'constructor' if method.static</pre></td><td><pre>        accesses = [new Access(new Literal('__super__'))];
        if (method.static) {
          accesses.push(new Access(new Literal('constructor')));
        }</pre></td></tr><tr valign="top"><td><pre>504,619,name</pre></td><td><pre>      accesses.push new Access new Literal name
      (new Value (new Literal method.klass), accesses).compile o
    else
      "#{name}.__super__.constructor"

  # Soaked chained invocations unfold into if/else ternary structures.</pre></td><td><pre>        accesses.push(new Access(new Literal(name)));
        return (new Value(new Literal(method.klass), accesses)).compile(o);
      } else {
        return "" + name + ".__super__.constructor";
      }
    };</pre></td></tr><tr valign="top"><td><pre>510,625,unfoldSoak</pre></td><td><pre>  unfoldSoak: (o) -&gt;</pre></td><td><pre>    Call.prototype.unfoldSoak = function(o) {
      var call, ifn, left, list, rite, _i, _len, _ref2, _ref3;</pre></td></tr><tr valign="top"><td><pre>511,627,soak</pre></td><td><pre>    if @soak</pre></td><td><pre>      if (this.soak) {</pre></td></tr><tr valign="top"><td><pre>512,628,variable</pre></td><td><pre>      if @variable
        return ifn if ifn = unfoldSoak o, this, 'variable'</pre></td><td><pre>        if (this.variable) {
          if (ifn = unfoldSoak(o, this, 'variable')) {
            return ifn;
          }</pre></td></tr><tr valign="top"><td><pre>514,632,left</pre></td><td><pre>        [left, rite] = new Value(@variable).cacheReference o
      else
        left = new Literal @superReference o
        rite = new Value left</pre></td><td><pre>          _ref2 = new Value(this.variable).cacheReference(o), left = _ref2[0], rite =
        } else {
          left = new Literal(this.superReference(o));
          rite = new Value(left);
        }</pre></td></tr><tr valign="top"><td><pre>518,637,Call</pre></td><td><pre>      rite = new Call rite, @args
      rite.isNew = @isNew
      left = new Literal "typeof #{ left.compile o } === \"function\""</pre></td><td><pre>        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal("typeof " + (left.compile(o)) + " === \"function\"");</pre></td></tr><tr valign="top"><td><pre>521,640,Value</pre></td><td><pre>      return new If left, new Value(rite), soak: yes
    call = this</pre></td><td><pre>        return new If(left, new Value(rite), {
          soak: true
        });
      }
      call = this;</pre></td></tr><tr valign="top"><td><pre>523,645,list</pre></td><td><pre>    list = []
    loop</pre></td><td><pre>      list = [];
      while (true) {</pre></td></tr><tr valign="top"><td><pre>525,647,variable</pre></td><td><pre>      if call.variable instanceof Call</pre></td><td><pre>        if (call.variable instanceof Call) {</pre></td></tr><tr valign="top"><td><pre>526,648,list</pre></td><td><pre>        list.push call</pre></td><td><pre>          list.push(call);</pre></td></tr><tr valign="top"><td><pre>527,649,variable</pre></td><td><pre>        call = call.variable</pre></td><td><pre>          call = call.variable;</pre></td></tr><tr valign="top"><td><pre>528,650,continue</pre></td><td><pre>        continue</pre></td><td><pre>          continue;
        }</pre></td></tr><tr valign="top"><td><pre>529,652,variable</pre></td><td><pre>      break unless call.variable instanceof Value</pre></td><td><pre>        if (!(call.variable instanceof Value)) {
          break;
        }</pre></td></tr><tr valign="top"><td><pre>530,655,list</pre></td><td><pre>      list.push call</pre></td><td><pre>        list.push(call);</pre></td></tr><tr valign="top"><td><pre>531,656,variable</pre></td><td><pre>      break unless (call = call.variable.base) instanceof Call</pre></td><td><pre>        if (!((call = call.variable.base) instanceof Call)) {
          break;
        }
      }</pre></td></tr><tr valign="top"><td><pre>532,660,list</pre></td><td><pre>    for call in list.reverse()</pre></td><td><pre>      _ref3 = list.reverse();
      for (_i = 0, _len = _ref3.length; _i &lt; _len; _i++) {
        call = _ref3[_i];</pre></td></tr><tr valign="top"><td><pre>533,663,ifn</pre></td><td><pre>      if ifn</pre></td><td><pre>        if (ifn) {</pre></td></tr><tr valign="top"><td><pre>534,664,variable</pre></td><td><pre>        if call.variable instanceof Call
          call.variable = ifn
        else</pre></td><td><pre>          if (call.variable instanceof Call) {
            call.variable = ifn;
          } else {</pre></td></tr><tr valign="top"><td><pre>537,667,base</pre></td><td><pre>          call.variable.base = ifn
      ifn = unfoldSoak o, call, 'variable'
    ifn

  # Walk through the objects in the arguments, moving over simple values.
  # This allows syntax like `call a: b, c` into `call({a: b}, c);`</pre></td><td><pre>            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, 'variable');
      }
      return ifn;
    };</pre></td></tr><tr valign="top"><td><pre>543,674,filterImplicitObjects</pre></td><td><pre>  filterImplicitObjects: (list) -&gt;</pre></td><td><pre>    Call.prototype.filterImplicitObjects = function(list) {
      var node, nodes, obj, prop, properties, _i, _j, _len, _len2, _ref2;</pre></td></tr><tr valign="top"><td><pre>544,676,nodes</pre></td><td><pre>    nodes = []</pre></td><td><pre>      nodes = [];</pre></td></tr><tr valign="top"><td><pre>545,677,list</pre></td><td><pre>    for node in list</pre></td><td><pre>      for (_i = 0, _len = list.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>546,678,node</pre></td><td><pre>      unless node.isObject?() and node.base.generated
        nodes.push node</pre></td><td><pre>        node = list[_i];
        if (!((typeof node.isObject === "function" ? node.isObject() : void 0) &amp;&amp; nod
          nodes.push(node);</pre></td></tr><tr valign="top"><td><pre>548,681,continue</pre></td><td><pre>        continue</pre></td><td><pre>          continue;
        }</pre></td></tr><tr valign="top"><td><pre>549,683,obj</pre></td><td><pre>      obj = null</pre></td><td><pre>        obj = null;</pre></td></tr><tr valign="top"><td><pre>550,684,node</pre></td><td><pre>      for prop in node.base.properties</pre></td><td><pre>        _ref2 = node.base.properties;
        for (_j = 0, _len2 = _ref2.length; _j &lt; _len2; _j++) {</pre></td></tr><tr valign="top"><td><pre>551,686,prop</pre></td><td><pre>        if prop instanceof Assign or prop instanceof Comment</pre></td><td><pre>          prop = _ref2[_j];
          if (prop instanceof Assign || prop instanceof Comment) {</pre></td></tr><tr valign="top"><td><pre>552,688,obj</pre></td><td><pre>          nodes.push obj = new Obj properties = [], true if not obj</pre></td><td><pre>            if (!obj) {</pre></td></tr><tr valign="top"><td><pre>553,689,properties</pre></td><td><pre>          properties.push prop
        else
          nodes.push prop
          obj = null
    nodes

  # Compile a vanilla function call.</pre></td><td><pre>              nodes.push(obj = new Obj(properties = [], true));
            }
            properties.push(prop);
          } else {
            nodes.push(prop);
            obj = null;
          }
        }
      }
      return nodes;
    };</pre></td></tr><tr valign="top"><td><pre>560,700,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Call.prototype.compileNode = function(o) {
      var arg, args, code, _ref2;</pre></td></tr><tr valign="top"><td><pre>561,702,variable</pre></td><td><pre>    @variable?.front = @front</pre></td><td><pre>      if ((_ref2 = this.variable) != null) {
        _ref2.front = this.front;
      }</pre></td></tr><tr valign="top"><td><pre>562,705,code</pre></td><td><pre>    if code = Splat.compileSplattedArray o, @args, true
      return @compileSplat o, code
    args = @filterImplicitObjects @args</pre></td><td><pre>      if (code = Splat.compileSplattedArray(o, this.args, true)) {
        return this.compileSplat(o, code);
      }
      args = this.filterImplicitObjects(this.args);
      args = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>565,713,arg</pre></td><td><pre>    args = (arg.compile o, LEVEL_LIST for arg in args).join ', '</pre></td><td><pre>          arg = args[_i];
          _results.push(arg.compile(o, LEVEL_LIST));
        }
        return _results;
      })()).join(', ');</pre></td></tr><tr valign="top"><td><pre>566,718,isSuper</pre></td><td><pre>    if @isSuper</pre></td><td><pre>      if (this.isSuper) {</pre></td></tr><tr valign="top"><td><pre>567,719,superReference</pre></td><td><pre>      @superReference(o) + ".call(this#{ args and ', ' + args })"
    else</pre></td><td><pre>        return this.superReference(o) + (".call(this" + (args &amp;&amp; ', ' + args) + ")");
      } else {</pre></td></tr><tr valign="top"><td><pre>569,721,isNew</pre></td><td><pre>      (if @isNew then 'new ' else '') + @variable.compile(o, LEVEL_ACCESS) + "(#{args

  # `super()` is converted into a call against the superclass's implementation
  # of the current function.
  compileSuper: (args, o) -&gt;
    "#{@superReference(o)}.call(this#{ if args.length then ', ' else '' }#{args})"

  # If you call a function with a splat, it's converted into a JavaScript
  # `.apply()` call to allow an array of arguments to be passed.
  # If it's a constructor, then things get real tricky. We have to inject an
  # inner constructor in order to be able to pass the varargs.</pre></td><td><pre>        return (this.isNew ? 'new ' : '') + this.variable.compile(o, LEVEL_ACCESS) + 
      }
    };
    Call.prototype.compileSuper = function(args, o) {
      return "" + (this.superReference(o)) + ".call(this" + (args.length ? ', ' : '')
    };</pre></td></tr><tr valign="top"><td><pre>580,727,compileSplat</pre></td><td><pre>  compileSplat: (o, splatArgs) -&gt;
    return "#{ @superReference o }.apply(this, #{splatArgs})" if @isSuper</pre></td><td><pre>    Call.prototype.compileSplat = function(o, splatArgs) {
      var base, fun, idt, name, ref;
      if (this.isSuper) {
        return "" + (this.superReference(o)) + ".apply(this, " + splatArgs + ")";
      }</pre></td></tr><tr valign="top"><td><pre>582,732,isNew</pre></td><td><pre>    if @isNew</pre></td><td><pre>      if (this.isNew) {</pre></td></tr><tr valign="top"><td><pre>583,733,idt</pre></td><td><pre>      idt = @tab + TAB
      return """</pre></td><td><pre>        idt = this.tab + TAB;</pre></td></tr><tr valign="top"><td><pre>585,734,function</pre></td><td><pre>        (function(func, args, ctor) {
        #{idt}ctor.prototype = func.prototype;
        #{idt}var child = new ctor, result = func.apply(child, args);
        #{idt}return typeof result === "object" ? result : child;
        #{@tab}})(#{ @variable.compile o, LEVEL_LIST }, #{splatArgs}, function() {})
      """
    base = new Value @variable</pre></td><td><pre>        return "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.proto
      }
      base = new Value(this.variable);</pre></td></tr><tr valign="top"><td><pre>592,737,name</pre></td><td><pre>    if (name = base.properties.pop()) and base.isComplex()</pre></td><td><pre>      if ((name = base.properties.pop()) &amp;&amp; base.isComplex()) {</pre></td></tr><tr valign="top"><td><pre>593,738,ref</pre></td><td><pre>      ref = o.scope.freeVariable 'ref'</pre></td><td><pre>        ref = o.scope.freeVariable('ref');</pre></td></tr><tr valign="top"><td><pre>594,739,fun</pre></td><td><pre>      fun = "(#{ref} = #{ base.compile o, LEVEL_LIST })#{ name.compile o }"
    else
      fun = base.compile o, LEVEL_ACCESS
      fun = "(#{fun})" if SIMPLENUM.test fun
      if name
        ref = fun
        fun += name.compile o
      else
        ref = 'null'
    "#{fun}.apply(#{ref}, #{splatArgs})"

#### Extends

# Node to extend an object's prototype with an ancestor object.
# After `goog.inherits` from the
# [Closure Library](http://closure-library.googlecode.com/svn/docs/closureGoogBase.js</pre></td><td><pre>        fun = "(" + ref + " = " + (base.compile(o, LEVEL_LIST)) + ")" + (name.compile
      } else {
        fun = base.compile(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fun)) {
          fun = "(" + fun + ")";
        }
        if (name) {
          ref = fun;
          fun += name.compile(o);
        } else {
          ref = 'null';
        }
      }
      return "" + fun + ".apply(" + ref + ", " + splatArgs + ")";
    };
    return Call;
  })();</pre></td></tr><tr valign="top"><td><pre>610,756,exports</pre></td><td><pre>exports.Extends = class Extends extends Base</pre></td><td><pre>  exports.Extends = Extends = (function() {
    __extends(Extends, Base);</pre></td></tr><tr valign="top"><td><pre>611,758,child</pre></td><td><pre>  constructor: (@child, @parent) -&gt;

  children: ['child', 'parent']

  # Hooks one constructor into another's prototype chain.</pre></td><td><pre>    function Extends(child, parent) {
      this.child = child;
      this.parent = parent;
    }
    Extends.prototype.children = ['child', 'parent'];</pre></td></tr><tr valign="top"><td><pre>616,763,compile</pre></td><td><pre>  compile: (o) -&gt;
    new Call(new Value(new Literal utility 'extends'), [@child, @parent]).compile o

#### Access

# A `.` access into a property of a value, or the `::` shorthand for
# an access into the object's prototype.</pre></td><td><pre>    Extends.prototype.compile = function(o) {
      return new Call(new Value(new Literal(utility('extends'))), [this.child, this.p
    };
    return Extends;
  })();</pre></td></tr><tr valign="top"><td><pre>623,768,exports</pre></td><td><pre>exports.Access = class Access extends Base</pre></td><td><pre>  exports.Access = Access = (function() {
    __extends(Access, Base);</pre></td></tr><tr valign="top"><td><pre>624,770,name</pre></td><td><pre>  constructor: (@name, tag) -&gt;
    @name.asKey = yes
    @soak  = tag is 'soak'
</pre></td><td><pre>    function Access(name, tag) {
      this.name = name;
      this.name.asKey = true;
      this.soak = tag === 'soak';
    }</pre></td></tr><tr valign="top"><td><pre>628,775,children</pre></td><td><pre>  children: ['name']
</pre></td><td><pre>    Access.prototype.children = ['name'];</pre></td></tr><tr valign="top"><td><pre>630,776,compile</pre></td><td><pre>  compile: (o) -&gt;
    name = @name.compile o</pre></td><td><pre>    Access.prototype.compile = function(o) {
      var name;
      name = this.name.compile(o);</pre></td></tr><tr valign="top"><td><pre>632,779,IDENTIFIER</pre></td><td><pre>    if IDENTIFIER.test name then ".#{name}" else "[#{name}]"
</pre></td><td><pre>      if (IDENTIFIER.test(name)) {
        return "." + name;
      } else {
        return "[" + name + "]";
      }
    };</pre></td></tr><tr valign="top"><td><pre>634,785,isComplex</pre></td><td><pre>  isComplex: NO

#### Index

# A `[ ... ]` indexed access into an array or object.</pre></td><td><pre>    Access.prototype.isComplex = NO;
    return Access;
  })();</pre></td></tr><tr valign="top"><td><pre>639,788,exports</pre></td><td><pre>exports.Index = class Index extends Base</pre></td><td><pre>  exports.Index = Index = (function() {
    __extends(Index, Base);</pre></td></tr><tr valign="top"><td><pre>640,790,index</pre></td><td><pre>  constructor: (@index) -&gt;

  children: ['index']
</pre></td><td><pre>    function Index(index) {
      this.index = index;
    }
    Index.prototype.children = ['index'];</pre></td></tr><tr valign="top"><td><pre>644,794,compile</pre></td><td><pre>  compile: (o) -&gt;
    "[#{ @index.compile o, LEVEL_PAREN }]"
</pre></td><td><pre>    Index.prototype.compile = function(o) {
      return "[" + (this.index.compile(o, LEVEL_PAREN)) + "]";
    };</pre></td></tr><tr valign="top"><td><pre>647,797,isComplex</pre></td><td><pre>  isComplex: -&gt;
    @index.isComplex()

#### Range

# A range literal. Ranges can be used to extract portions (slices) of arrays,
# to specify a range for comprehensions, or as a value, to be expanded into the
# corresponding array of integers at runtime.</pre></td><td><pre>    Index.prototype.isComplex = function() {
      return this.index.isComplex();
    };
    return Index;
  })();</pre></td></tr><tr valign="top"><td><pre>655,802,exports</pre></td><td><pre>exports.Range = class Range extends Base
</pre></td><td><pre>  exports.Range = Range = (function() {
    __extends(Range, Base);</pre></td></tr><tr valign="top"><td><pre>657,804,children</pre></td><td><pre>  children: ['from', 'to']

  constructor: (@from, @to, tag) -&gt;</pre></td><td><pre>    Range.prototype.children = ['from', 'to'];
    function Range(from, to, tag) {
      this.from = from;
      this.to = to;</pre></td></tr><tr valign="top"><td><pre>660,808,exclusive</pre></td><td><pre>    @exclusive = tag is 'exclusive'
    @equals = if @exclusive then '' else '='

  # Compiles the range's source variables -- where it starts and where it ends.
  # But only if they need to be cached to avoid double evaluation.</pre></td><td><pre>      this.exclusive = tag === 'exclusive';
      this.equals = this.exclusive ? '' : '=';
    }</pre></td></tr><tr valign="top"><td><pre>665,811,compileVariables</pre></td><td><pre>  compileVariables: (o) -&gt;</pre></td><td><pre>    Range.prototype.compileVariables = function(o) {
      var step, _ref2, _ref3, _ref4, _ref5;</pre></td></tr><tr valign="top"><td><pre>666,813,merge</pre></td><td><pre>    o = merge o, top: true</pre></td><td><pre>      o = merge(o, {
        top: true
      });</pre></td></tr><tr valign="top"><td><pre>667,816,fromC</pre></td><td><pre>    [@fromC, @fromVar]  =  @from.cache o, LEVEL_LIST
    [@toC, @toVar]      =  @to.cache o, LEVEL_LIST</pre></td><td><pre>      _ref2 = this.from.cache(o, LEVEL_LIST), this.fromC = _ref2[0], this.fromVar = _
      _ref3 = this.to.cache(o, LEVEL_LIST), this.toC = _ref3[0], this.toVar = _ref3[1</pre></td></tr><tr valign="top"><td><pre>669,818,step</pre></td><td><pre>    [@step, @stepVar]   =  step.cache o, LEVEL_LIST if step = del o, 'step'</pre></td><td><pre>      if (step = del(o, 'step')) {
        _ref4 = step.cache(o, LEVEL_LIST), this.step = _ref4[0], this.stepVar = _ref4
      }</pre></td></tr><tr valign="top"><td><pre>670,821,fromNum</pre></td><td><pre>    [@fromNum, @toNum]  = [@fromVar.match(SIMPLENUM), @toVar.match(SIMPLENUM)]
    @stepNum            = @stepVar.match(SIMPLENUM) if @stepVar

  # When compiled normally, the range returns the contents of the *for loop*
  # needed to iterate over the values in the range. Used by comprehensions.</pre></td><td><pre>      _ref5 = [this.fromVar.match(SIMPLENUM), this.toVar.match(SIMPLENUM)], this.from
      if (this.stepVar) {
        return this.stepNum = this.stepVar.match(SIMPLENUM);
      }
    };</pre></td></tr><tr valign="top"><td><pre>675,826,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Range.prototype.compileNode = function(o) {
      var cond, condPart, from, gt, idx, known, lt, stepPart, to, varPart, _ref2, _re</pre></td></tr><tr valign="top"><td><pre>676,828,fromVar</pre></td><td><pre>    @compileVariables o unless @fromVar</pre></td><td><pre>      if (!this.fromVar) {
        this.compileVariables(o);
      }</pre></td></tr><tr valign="top"><td><pre>677,831,index</pre></td><td><pre>    return @compileArray(o) unless o.index

    # Set up endpoints.</pre></td><td><pre>      if (!o.index) {
        return this.compileArray(o);
      }</pre></td></tr><tr valign="top"><td><pre>680,834,known</pre></td><td><pre>    known    = @fromNum and @toNum</pre></td><td><pre>      known = this.fromNum &amp;&amp; this.toNum;</pre></td></tr><tr valign="top"><td><pre>681,835,idx</pre></td><td><pre>    idx      = del o, 'index'</pre></td><td><pre>      idx = del(o, 'index');</pre></td></tr><tr valign="top"><td><pre>682,836,varPart</pre></td><td><pre>    varPart  = "#{idx} = #{@fromC}"
    varPart += ", #{@toC}" if @toC isnt @toVar
    varPart += ", #{@step}" if @step isnt @stepVar
    [lt, gt] = ["#{idx} &lt;#{@equals}", "#{idx} &gt;#{@equals}"]

    # Generate the condition.</pre></td><td><pre>      varPart = "" + idx + " = " + this.fromC;
      if (this.toC !== this.toVar) {
        varPart += ", " + this.toC;
      }
      if (this.step !== this.stepVar) {
        varPart += ", " + this.step;
      }
      _ref2 = ["" + idx + " &lt;" + this.equals, "" + idx + " &gt;" + this.equals], lt = _r</pre></td></tr><tr valign="top"><td><pre>688,844,condPart</pre></td><td><pre>    condPart = if @stepNum
      if +@stepNum &gt; 0 then "#{lt} #{@toVar}" else "#{gt} #{@toVar}"
    else if known
      [from, to] = [+@fromNum, +@toNum]
      if from &lt;= to then "#{lt} #{to}" else "#{gt} #{to}"
    else
      cond     = "#{@fromVar} &lt;= #{@toVar}"
      "#{cond} ? #{lt} #{@toVar} : #{gt} #{@toVar}"

    # Generate the step.</pre></td><td><pre>      condPart = this.stepNum ? +this.stepNum &gt; 0 ? "" + lt + " " + this.toVar : "" +</pre></td></tr><tr valign="top"><td><pre>698,845,stepPart</pre></td><td><pre>    stepPart = if @stepVar
      "#{idx} += #{@stepVar}"
    else if known
      if from &lt;= to then "#{idx}++" else "#{idx}--"
    else
      "#{cond} ? #{idx}++ : #{idx}--"

    # The final loop body.
    "#{varPart}; #{condPart}; #{stepPart}"


  # When used as a value, expand the range into the equivalent array.</pre></td><td><pre>      stepPart = this.stepVar ? "" + idx + " += " + this.stepVar : known ? from &lt;= to
      return "" + varPart + "; " + condPart + "; " + stepPart;
    };</pre></td></tr><tr valign="top"><td><pre>710,848,compileArray</pre></td><td><pre>  compileArray: (o) -&gt;</pre></td><td><pre>    Range.prototype.compileArray = function(o) {
      var args, body, cond, hasArgs, i, idt, post, pre, range, result, vars, _i, _ref</pre></td></tr><tr valign="top"><td><pre>711,850,fromNum</pre></td><td><pre>    if @fromNum and @toNum and Math.abs(@fromNum - @toNum) &lt;= 20
      range = [+@fromNum..+@toNum]</pre></td><td><pre>      if (this.fromNum &amp;&amp; this.toNum &amp;&amp; Math.abs(this.fromNum - this.toNum) &lt;= 20) {
        range = (function() {
          _results = [];
          for (var _i = _ref2 = +this.fromNum, _ref3 = +this.toNum; _ref2 &lt;= _ref3 ? 
          return _results;
        }).apply(this, arguments);</pre></td></tr><tr valign="top"><td><pre>713,856,exclusive</pre></td><td><pre>      range.pop() if @exclusive
      return "[#{ range.join(', ') }]"</pre></td><td><pre>        if (this.exclusive) {
          range.pop();
        }
        return "[" + (range.join(', ')) + "]";
      }</pre></td></tr><tr valign="top"><td><pre>715,861,idt</pre></td><td><pre>    idt    = @tab + TAB</pre></td><td><pre>      idt = this.tab + TAB;</pre></td></tr><tr valign="top"><td><pre>716,862,scope</pre></td><td><pre>    i      = o.scope.freeVariable 'i'
    result = o.scope.freeVariable 'results'</pre></td><td><pre>      i = o.scope.freeVariable('i');
      result = o.scope.freeVariable('results');</pre></td></tr><tr valign="top"><td><pre>718,864,pre</pre></td><td><pre>    pre    = "\n#{idt}#{result} = [];"</pre></td><td><pre>      pre = "\n" + idt + result + " = [];";</pre></td></tr><tr valign="top"><td><pre>719,865,fromNum</pre></td><td><pre>    if @fromNum and @toNum</pre></td><td><pre>      if (this.fromNum &amp;&amp; this.toNum) {</pre></td></tr><tr valign="top"><td><pre>720,866,index</pre></td><td><pre>      o.index = i</pre></td><td><pre>        o.index = i;</pre></td></tr><tr valign="top"><td><pre>721,867,body</pre></td><td><pre>      body    = @compileNode o
    else</pre></td><td><pre>        body = this.compileNode(o);
      } else {</pre></td></tr><tr valign="top"><td><pre>723,869,vars</pre></td><td><pre>      vars    = "#{i} = #{@fromC}" + if @toC isnt @toVar then ", #{@toC}" else ''</pre></td><td><pre>        vars = ("" + i + " = " + this.fromC) + (this.toC !== this.toVar ? ", " + this</pre></td></tr><tr valign="top"><td><pre>724,870,cond</pre></td><td><pre>      cond    = "#{@fromVar} &lt;= #{@toVar}"</pre></td><td><pre>        cond = "" + this.fromVar + " &lt;= " + this.toVar;</pre></td></tr><tr valign="top"><td><pre>725,871,body</pre></td><td><pre>      body    = "var #{vars}; #{cond} ? #{i} &lt;#{@equals} #{@toVar} : #{i} &gt;#{@equals}</pre></td><td><pre>        body = "var " + vars + "; " + cond + " ? " + i + " &lt;" + this.equals + " " + t
      }</pre></td></tr><tr valign="top"><td><pre>726,873,post</pre></td><td><pre>    post   = "{ #{result}.push(#{i}); }\n#{idt}return #{result};\n#{o.indent}"</pre></td><td><pre>      post = "{ " + result + ".push(" + i + "); }\n" + idt + "return " + result + ";\</pre></td></tr><tr valign="top"><td><pre>727,874,hasArgs</pre></td><td><pre>    hasArgs = (node) -&gt; node?.contains (n) -&gt; n instanceof Literal and n.value is 'ar
    args   = ', arguments' if hasArgs(@from) or hasArgs(@to)
    "(function() {#{pre}\n#{idt}for (#{body})#{post}}).apply(this#{args ? ''})"

#### Slice

# An array slice literal. Unlike JavaScript's `Array#slice`, the second parameter
# specifies the index of the end of the slice, just as the first parameter
# is the index of the beginning.</pre></td><td><pre>      hasArgs = function(node) {
        return node != null ? node.contains(function(n) {
          return n instanceof Literal &amp;&amp; n.value === 'arguments' &amp;&amp; !n.asKey;
        }) : void 0;
      };
      if (hasArgs(this.from) || hasArgs(this.to)) {
        args = ', arguments';
      }
      return "(function() {" + pre + "\n" + idt + "for (" + body + ")" + post + "}).a
    };
    return Range;
  })();</pre></td></tr><tr valign="top"><td><pre>736,886,exports</pre></td><td><pre>exports.Slice = class Slice extends Base
</pre></td><td><pre>  exports.Slice = Slice = (function() {
    __extends(Slice, Base);</pre></td></tr><tr valign="top"><td><pre>738,888,children</pre></td><td><pre>  children: ['range']

  constructor: (@range) -&gt;
    super()

  # We have to be careful when trying to slice through the end of the array,
  # `9e9` is used because not all implementations respect `undefined` or `1/0`.
  # `9e9` should be safe because `9e9` &gt; `2**32`, the max array length.</pre></td><td><pre>    Slice.prototype.children = ['range'];
    function Slice(range) {
      this.range = range;
      Slice.__super__.constructor.call(this);
    }</pre></td></tr><tr valign="top"><td><pre>746,893,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Slice.prototype.compileNode = function(o) {
      var compiled, from, fromStr, to, toStr, _ref2;</pre></td></tr><tr valign="top"><td><pre>747,895,from</pre></td><td><pre>    {to, from} = @range
    fromStr    = from and from.compile(o, LEVEL_PAREN) or '0'</pre></td><td><pre>      _ref2 = this.range, to = _ref2.to, from = _ref2.from;
      fromStr = from &amp;&amp; from.compile(o, LEVEL_PAREN) || '0';</pre></td></tr><tr valign="top"><td><pre>749,897,compiled</pre></td><td><pre>    compiled   = to and to.compile o, LEVEL_ACCESS
    if to and not (not @range.exclusive and +compiled is -1)</pre></td><td><pre>      compiled = to &amp;&amp; to.compile(o, LEVEL_ACCESS);
      if (to &amp;&amp; !(!this.range.exclusive &amp;&amp; +compiled === -1)) {</pre></td></tr><tr valign="top"><td><pre>751,899,toStr</pre></td><td><pre>      toStr = ', ' + if @range.exclusive
        compiled
      else if SIMPLENUM.test compiled
        (+compiled + 1).toString()
      else
        "#{compiled} + 1 || 9e9"</pre></td><td><pre>        toStr = ', ' + (this.range.exclusive ? compiled : SIMPLENUM.test(compiled) ? 
      }</pre></td></tr><tr valign="top"><td><pre>757,901,slice</pre></td><td><pre>    ".slice(#{ fromStr }#{ toStr or '' })"

#### Obj

# An object literal, nothing fancy.</pre></td><td><pre>      return ".slice(" + fromStr + (toStr || '') + ")";
    };
    return Slice;
  })();</pre></td></tr><tr valign="top"><td><pre>762,905,exports</pre></td><td><pre>exports.Obj = class Obj extends Base</pre></td><td><pre>  exports.Obj = Obj = (function() {
    __extends(Obj, Base);</pre></td></tr><tr valign="top"><td><pre>763,907,props</pre></td><td><pre>  constructor: (props, @generated = false) -&gt;
    @objects = @properties = props or []
</pre></td><td><pre>    function Obj(props, generated) {
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
    }</pre></td></tr><tr valign="top"><td><pre>766,911,children</pre></td><td><pre>  children: ['properties']
</pre></td><td><pre>    Obj.prototype.children = ['properties'];</pre></td></tr><tr valign="top"><td><pre>768,912,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Obj.prototype.compileNode = function(o) {
      var i, idt, indent, join, lastNoncom, node, obj, prop, props, _i, _len;</pre></td></tr><tr valign="top"><td><pre>769,914,props</pre></td><td><pre>    props = @properties
    return (if @front then '({})' else '{}') unless props.length</pre></td><td><pre>      props = this.properties;
      if (!props.length) {
        if (this.front) {
          return '({})';
        } else {
          return '{}';
        }
      }</pre></td></tr><tr valign="top"><td><pre>771,922,generated</pre></td><td><pre>    if @generated</pre></td><td><pre>      if (this.generated) {</pre></td></tr><tr valign="top"><td><pre>772,923,props</pre></td><td><pre>      for node in props when node instanceof Value</pre></td><td><pre>        for (_i = 0, _len = props.length; _i &lt; _len; _i++) {
          node = props[_i];
          if (node instanceof Value) {</pre></td></tr><tr valign="top"><td><pre>773,926,throw</pre></td><td><pre>        throw new Error 'cannot have an implicit value in an implicit object'</pre></td><td><pre>            throw new Error('cannot have an implicit value in an implicit object');
          }
        }
      }</pre></td></tr><tr valign="top"><td><pre>774,930,idt</pre></td><td><pre>    idt         = o.indent += TAB</pre></td><td><pre>      idt = o.indent += TAB;</pre></td></tr><tr valign="top"><td><pre>775,931,lastNoncom</pre></td><td><pre>    lastNoncom  = @lastNonComment @properties</pre></td><td><pre>      lastNoncom = this.lastNonComment(this.properties);</pre></td></tr><tr valign="top"><td><pre>776,932,props</pre></td><td><pre>    props = for prop, i in props
      join = if i is props.length - 1
        ''</pre></td><td><pre>      props = (function() {
        var _len2, _results;
        _results = [];
        for (i = 0, _len2 = props.length; i &lt; _len2; i++) {</pre></td></tr><tr valign="top"><td><pre>779,936,prop</pre></td><td><pre>      else if prop is lastNoncom or prop instanceof Comment
        '\n'
      else
        ',\n'
      indent = if prop instanceof Comment then '' else idt</pre></td><td><pre>          prop = props[i];
          join = i === props.length - 1 ? '' : prop === lastNoncom || prop instanceof
          indent = prop instanceof Comment ? '' : idt;</pre></td></tr><tr valign="top"><td><pre>784,939,Value</pre></td><td><pre>      if prop instanceof Value and prop.this
        prop = new Assign prop.properties[0].name, prop, 'object'
      if prop not instanceof Comment
        if prop not instanceof Assign
          prop = new Assign prop, prop, 'object'</pre></td><td><pre>          if (prop instanceof Value &amp;&amp; prop["this"]) {
            prop = new Assign(prop.properties[0].name, prop, 'object');
          }
          if (!(prop instanceof Comment)) {
            if (!(prop instanceof Assign)) {
              prop = new Assign(prop, prop, 'object');
            }</pre></td></tr><tr valign="top"><td><pre>789,946,variable</pre></td><td><pre>        (prop.variable.base or prop.variable).asKey = yes
      indent + prop.compile(o, LEVEL_TOP) + join</pre></td><td><pre>            (prop.variable.base || prop.variable).asKey = true;
          }
          _results.push(indent + prop.compile(o, LEVEL_TOP) + join);
        }
        return _results;
      })();</pre></td></tr><tr valign="top"><td><pre>791,952,props</pre></td><td><pre>    props = props.join ''</pre></td><td><pre>      props = props.join('');</pre></td></tr><tr valign="top"><td><pre>792,953,obj</pre></td><td><pre>    obj   = "{#{ props and '\n' + props + '\n' + @tab }}"</pre></td><td><pre>      obj = "{" + (props &amp;&amp; '\n' + props + '\n' + this.tab) + "}";</pre></td></tr><tr valign="top"><td><pre>793,954,front</pre></td><td><pre>    if @front then "(#{obj})" else obj
</pre></td><td><pre>      if (this.front) {
        return "(" + obj + ")";
      } else {
        return obj;
      }
    };</pre></td></tr><tr valign="top"><td><pre>795,960,assigns</pre></td><td><pre>  assigns: (name) -&gt;
    for prop in @properties when prop.assigns name then return yes
    no

#### Arr

# An array literal.</pre></td><td><pre>    Obj.prototype.assigns = function(name) {
      var prop, _i, _len, _ref2;
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        prop = _ref2[_i];
        if (prop.assigns(name)) {
          return true;
        }
      }
      return false;
    };
    return Obj;
  })();</pre></td></tr><tr valign="top"><td><pre>802,973,exports</pre></td><td><pre>exports.Arr = class Arr extends Base</pre></td><td><pre>  exports.Arr = Arr = (function() {
    __extends(Arr, Base);</pre></td></tr><tr valign="top"><td><pre>803,975,objs</pre></td><td><pre>  constructor: (objs) -&gt;
    @objects = objs or []
</pre></td><td><pre>    function Arr(objs) {
      this.objects = objs || [];
    }</pre></td></tr><tr valign="top"><td><pre>806,978,children</pre></td><td><pre>  children: ['objects']
</pre></td><td><pre>    Arr.prototype.children = ['objects'];</pre></td></tr><tr valign="top"><td><pre>808,979,filterImplicitObjects</pre></td><td><pre>  filterImplicitObjects: Call::filterImplicitObjects
</pre></td><td><pre>    Arr.prototype.filterImplicitObjects = Call.prototype.filterImplicitObjects;</pre></td></tr><tr valign="top"><td><pre>810,980,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Arr.prototype.compileNode = function(o) {
      var code, obj, objs;</pre></td></tr><tr valign="top"><td><pre>811,982,objects</pre></td><td><pre>    return '[]' unless @objects.length</pre></td><td><pre>      if (!this.objects.length) {
        return '[]';
      }</pre></td></tr><tr valign="top"><td><pre>812,985,indent</pre></td><td><pre>    o.indent += TAB</pre></td><td><pre>      o.indent += TAB;</pre></td></tr><tr valign="top"><td><pre>813,986,objs</pre></td><td><pre>    objs = @filterImplicitObjects @objects
    return code if code = Splat.compileSplattedArray o, objs</pre></td><td><pre>      objs = this.filterImplicitObjects(this.objects);
      if (code = Splat.compileSplattedArray(o, objs)) {
        return code;
      }
      code = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = objs.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>815,994,obj</pre></td><td><pre>    code = (obj.compile o, LEVEL_LIST for obj in objs).join ', '</pre></td><td><pre>          obj = objs[_i];
          _results.push(obj.compile(o, LEVEL_LIST));
        }
        return _results;
      })()).join(', ');</pre></td></tr><tr valign="top"><td><pre>816,999,code</pre></td><td><pre>    if code.indexOf('\n') &gt;= 0
      "[\n#{o.indent}#{code}\n#{@tab}]"
    else
      "[#{code}]"
</pre></td><td><pre>      if (code.indexOf('\n') &gt;= 0) {
        return "[\n" + o.indent + code + "\n" + this.tab + "]";
      } else {
        return "[" + code + "]";
      }
    };</pre></td></tr><tr valign="top"><td><pre>821,1005,assigns</pre></td><td><pre>  assigns: (name) -&gt;
    for obj in @objects when obj.assigns name then return yes
    no

#### Class

# The CoffeeScript class definition.
# Initialize a **Class** with its name, an optional superclass, and a
# list of prototype property assignments.</pre></td><td><pre>    Arr.prototype.assigns = function(name) {
      var obj, _i, _len, _ref2;
      _ref2 = this.objects;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        obj = _ref2[_i];
        if (obj.assigns(name)) {
          return true;
        }
      }
      return false;
    };
    return Arr;
  })();</pre></td></tr><tr valign="top"><td><pre>830,1018,exports</pre></td><td><pre>exports.Class = class Class extends Base</pre></td><td><pre>  exports.Class = Class = (function() {
    __extends(Class, Base);</pre></td></tr><tr valign="top"><td><pre>831,1020,variable</pre></td><td><pre>  constructor: (@variable, @parent, @body = new Block) -&gt;</pre></td><td><pre>    function Class(variable, parent, body) {
      this.variable = variable;
      this.parent = parent;
      this.body = body != null ? body : new Block;</pre></td></tr><tr valign="top"><td><pre>832,1024,boundFuncs</pre></td><td><pre>    @boundFuncs = []</pre></td><td><pre>      this.boundFuncs = [];</pre></td></tr><tr valign="top"><td><pre>833,1025,body</pre></td><td><pre>    @body.classBody = yes

  children: ['variable', 'parent', 'body']

  # Figure out the appropriate name for the constructor function of this class.</pre></td><td><pre>      this.body.classBody = true;
    }
    Class.prototype.children = ['variable', 'parent', 'body'];</pre></td></tr><tr valign="top"><td><pre>838,1028,determineName</pre></td><td><pre>  determineName: -&gt;</pre></td><td><pre>    Class.prototype.determineName = function() {
      var decl, tail;</pre></td></tr><tr valign="top"><td><pre>839,1030,variable</pre></td><td><pre>    return null unless @variable
    decl = if tail = last @variable.properties</pre></td><td><pre>      if (!this.variable) {
        return null;
      }</pre></td></tr><tr valign="top"><td><pre>841,1033,instanceof</pre></td><td><pre>      tail instanceof Access and tail.name.value
    else
      @variable.base.value
    decl and= IDENTIFIER.test(decl) and decl

  # For all `this`-references and bound functions in the class definition,
  # `this` is the Class being constructed.
  setContext: (name) -&gt;</pre></td><td><pre>      decl = (tail = last(this.variable.properties)) ? tail instanceof Access &amp;&amp; tail
      return decl &amp;&amp; (decl = IDENTIFIER.test(decl) &amp;&amp; decl);
    };
    Class.prototype.setContext = function(name) {</pre></td></tr><tr valign="top"><td><pre>849,1037,body</pre></td><td><pre>    @body.traverseChildren false, (node) -&gt;
      return false if node.classBody</pre></td><td><pre>      return this.body.traverseChildren(false, function(node) {
        if (node.classBody) {
          return false;
        }</pre></td></tr><tr valign="top"><td><pre>851,1041,instanceof</pre></td><td><pre>      if node instanceof Literal and node.value is 'this'
        node.value    = name
      else if node instanceof Code</pre></td><td><pre>        if (node instanceof Literal &amp;&amp; node.value === 'this') {
          return node.value = name;
        } else if (node instanceof Code) {</pre></td></tr><tr valign="top"><td><pre>854,1044,klass</pre></td><td><pre>        node.klass    = name
        node.context  = name if node.bound

  # Ensure that all functions bound to the instance are proxied in the
  # constructor.</pre></td><td><pre>          node.klass = name;
          if (node.bound) {
            return node.context = name;
          }
        }
      });
    };</pre></td></tr><tr valign="top"><td><pre>859,1051,addBoundFunctions</pre></td><td><pre>  addBoundFunctions: (o) -&gt;</pre></td><td><pre>    Class.prototype.addBoundFunctions = function(o) {
      var bvar, lhs, _i, _len, _ref2, _results;</pre></td></tr><tr valign="top"><td><pre>860,1053,boundFuncs</pre></td><td><pre>    if @boundFuncs.length
      for bvar in @boundFuncs</pre></td><td><pre>      if (this.boundFuncs.length) {
        _ref2 = this.boundFuncs;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
          bvar = _ref2[_i];</pre></td></tr><tr valign="top"><td><pre>862,1058,lhs</pre></td><td><pre>        lhs = (new Value (new Literal "this"), [new Access bvar]).compile o
        @ctor.body.unshift new Literal "#{lhs} = #{utility 'bind'}(#{lhs}, this)"

  # Merge the properties from a top-level object as prototypal properties
  # on the class.</pre></td><td><pre>          lhs = (new Value(new Literal("this"), [new Access(bvar)])).compile(o);
          _results.push(this.ctor.body.unshift(new Literal("" + lhs + " = " + (utilit
        }
        return _results;
      }
    };</pre></td></tr><tr valign="top"><td><pre>867,1064,addProperties</pre></td><td><pre>  addProperties: (node, name, o) -&gt;
    props = node.base.properties[0..]</pre></td><td><pre>    Class.prototype.addProperties = function(node, name, o) {
      var assign, base, exprs, func, props;
      props = node.base.properties.slice(0);</pre></td></tr><tr valign="top"><td><pre>869,1067,exprs</pre></td><td><pre>    exprs = while assign = props.shift()</pre></td><td><pre>      exprs = (function() {
        var _results;
        _results = [];</pre></td></tr><tr valign="top"><td><pre>870,1070,assign</pre></td><td><pre>      if assign instanceof Assign
        base = assign.variable.base</pre></td><td><pre>        while (assign = props.shift()) {
          if (assign instanceof Assign) {
            base = assign.variable.base;</pre></td></tr><tr valign="top"><td><pre>872,1073,delete</pre></td><td><pre>        delete assign.context
        func = assign.value</pre></td><td><pre>            delete assign.context;
            func = assign.value;</pre></td></tr><tr valign="top"><td><pre>874,1075,base</pre></td><td><pre>        if base.value is 'constructor'</pre></td><td><pre>            if (base.value === 'constructor') {</pre></td></tr><tr valign="top"><td><pre>875,1076,ctor</pre></td><td><pre>          if @ctor</pre></td><td><pre>              if (this.ctor) {</pre></td></tr><tr valign="top"><td><pre>876,1077,throw</pre></td><td><pre>            throw new Error 'cannot define more than one constructor in a class'</pre></td><td><pre>                throw new Error('cannot define more than one constructor in a class')
              }</pre></td></tr><tr valign="top"><td><pre>877,1079,func</pre></td><td><pre>          if func.bound
            throw new Error 'cannot define a constructor as a bound function'
          if func instanceof Code</pre></td><td><pre>              if (func.bound) {
                throw new Error('cannot define a constructor as a bound function');
              }
              if (func instanceof Code) {</pre></td></tr><tr valign="top"><td><pre>880,1083,assign</pre></td><td><pre>            assign = @ctor = func
          else</pre></td><td><pre>                assign = this.ctor = func;
              } else {</pre></td></tr><tr valign="top"><td><pre>882,1085,externalCtor</pre></td><td><pre>            @externalCtor = o.scope.freeVariable 'class'
            assign = new Assign new Literal(@externalCtor), func
        else</pre></td><td><pre>                this.externalCtor = o.scope.freeVariable('class');
                assign = new Assign(new Literal(this.externalCtor), func);
              }
            } else {</pre></td></tr><tr valign="top"><td><pre>885,1089,variable</pre></td><td><pre>          if assign.variable.this</pre></td><td><pre>              if (assign.variable["this"]) {</pre></td></tr><tr valign="top"><td><pre>886,1090,func</pre></td><td><pre>            func.static = yes
          else</pre></td><td><pre>                func.static = true;
              } else {</pre></td></tr><tr valign="top"><td><pre>888,1092,assign</pre></td><td><pre>            assign.variable = new Value(new Literal(name), [(new Access new Literal '</pre></td><td><pre>                assign.variable = new Value(new Literal(name), [new Access(new Litera</pre></td></tr><tr valign="top"><td><pre>889,1093,func</pre></td><td><pre>            if func instanceof Code and func.bound</pre></td><td><pre>                if (func instanceof Code &amp;&amp; func.bound) {</pre></td></tr><tr valign="top"><td><pre>890,1094,boundFuncs</pre></td><td><pre>              @boundFuncs.push base</pre></td><td><pre>                  this.boundFuncs.push(base);</pre></td></tr><tr valign="top"><td><pre>891,1095,func</pre></td><td><pre>              func.bound = no</pre></td><td><pre>                  func.bound = false;
                }
              }
            }
          }</pre></td></tr><tr valign="top"><td><pre>892,1100,assign</pre></td><td><pre>      assign</pre></td><td><pre>          _results.push(assign);
        }
        return _results;
      }).call(this);</pre></td></tr><tr valign="top"><td><pre>893,1104,compact</pre></td><td><pre>    compact exprs

  # Walk the body of the class, looking for prototype properties to be converted.</pre></td><td><pre>      return compact(exprs);
    };</pre></td></tr><tr valign="top"><td><pre>896,1106,walkBody</pre></td><td><pre>  walkBody: (name, o) -&gt;</pre></td><td><pre>    Class.prototype.walkBody = function(name, o) {</pre></td></tr><tr valign="top"><td><pre>897,1107,traverseChildren</pre></td><td><pre>    @traverseChildren false, (child) =&gt;
      return false if child instanceof Class</pre></td><td><pre>      return this.traverseChildren(false, __bind(function(child) {
        var exps, i, node, _len, _ref2;
        if (child instanceof Class) {
          return false;
        }</pre></td></tr><tr valign="top"><td><pre>899,1112,Block</pre></td><td><pre>      if child instanceof Block
        for node, i in exps = child.expressions
          if node instanceof Value and node.isObject(true)</pre></td><td><pre>        if (child instanceof Block) {
          _ref2 = exps = child.expressions;
          for (i = 0, _len = _ref2.length; i &lt; _len; i++) {
            node = _ref2[i];
            if (node instanceof Value &amp;&amp; node.isObject(true)) {</pre></td></tr><tr valign="top"><td><pre>902,1117,addProperties</pre></td><td><pre>            exps[i] = @addProperties node, name, o
        child.expressions = exps = flatten exps

  # Make sure that a constructor is defined for the class, and properly
  # configured.
  ensureConstructor: (name) -&gt;</pre></td><td><pre>              exps[i] = this.addProperties(node, name, o);
            }
          }
          return child.expressions = exps = flatten(exps);
        }
      }, this));
    };
    Class.prototype.ensureConstructor = function(name) {</pre></td></tr><tr valign="top"><td><pre>908,1125,ctor</pre></td><td><pre>    if not @ctor
      @ctor = new Code</pre></td><td><pre>      if (!this.ctor) {
        this.ctor = new Code;
        if (this.parent) {</pre></td></tr><tr valign="top"><td><pre>910,1128,body</pre></td><td><pre>      @ctor.body.push new Literal "#{name}.__super__.constructor.apply(this, argument
      @ctor.body.push new Literal "#{@externalCtor}.apply(this, arguments)" if @exter</pre></td><td><pre>          this.ctor.body.push(new Literal("" + name + ".__super__.constructor.apply(t
        }
        if (this.externalCtor) {
          this.ctor.body.push(new Literal("" + this.externalCtor + ".apply(this, argu
        }</pre></td></tr><tr valign="top"><td><pre>912,1133,expressions</pre></td><td><pre>      @body.expressions.unshift @ctor
    @ctor.ctor     = @ctor.name = name</pre></td><td><pre>        this.body.expressions.unshift(this.ctor);
      }
      this.ctor.ctor = this.ctor.name = name;</pre></td></tr><tr valign="top"><td><pre>914,1136,klass</pre></td><td><pre>    @ctor.klass    = null
    @ctor.noReturn = yes

  # Instead of generating the JavaScript string directly, we build up the
  # equivalent syntax tree and compile that, in pieces. You can see the
  # constructor, property assignments, and inheritance getting built out below.</pre></td><td><pre>      this.ctor.klass = null;
      return this.ctor.noReturn = true;
    };</pre></td></tr><tr valign="top"><td><pre>920,1139,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Class.prototype.compileNode = function(o) {
      var decl, klass, lname, name;</pre></td></tr><tr valign="top"><td><pre>921,1141,decl</pre></td><td><pre>    decl  = @determineName()
    name  = decl or @name or '_Class'
    name = "_#{name}" if name.reserved</pre></td><td><pre>      decl = this.determineName();
      name = decl || this.name || '_Class';
      if (name.reserved) {
        name = "_" + name;
      }</pre></td></tr><tr valign="top"><td><pre>924,1146,lname</pre></td><td><pre>    lname = new Literal name

    @setContext name</pre></td><td><pre>      lname = new Literal(name);
      this.setContext(name);</pre></td></tr><tr valign="top"><td><pre>927,1148,walkBody</pre></td><td><pre>    @walkBody name, o
    @ensureConstructor name</pre></td><td><pre>      this.walkBody(name, o);
      this.ensureConstructor(name);</pre></td></tr><tr valign="top"><td><pre>929,1150,body</pre></td><td><pre>    @body.spaced = yes
    @body.expressions.unshift new Extends lname, @parent if @parent</pre></td><td><pre>      this.body.spaced = true;
      if (this.parent) {
        this.body.expressions.unshift(new Extends(lname, this.parent));
      }</pre></td></tr><tr valign="top"><td><pre>931,1154,ctor</pre></td><td><pre>    @body.expressions.unshift @ctor unless @ctor instanceof Code</pre></td><td><pre>      if (!(this.ctor instanceof Code)) {</pre></td></tr><tr valign="top"><td><pre>932,1155,body</pre></td><td><pre>    @body.expressions.push lname</pre></td><td><pre>        this.body.expressions.unshift(this.ctor);
      }
      this.body.expressions.push(lname);</pre></td></tr><tr valign="top"><td><pre>933,1158,addBoundFunctions</pre></td><td><pre>    @addBoundFunctions o
</pre></td><td><pre>      this.addBoundFunctions(o);</pre></td></tr><tr valign="top"><td><pre>935,1159,klass</pre></td><td><pre>    klass = new Parens Closure.wrap(@body), true
    klass = new Assign @variable, klass if @variable</pre></td><td><pre>      klass = new Parens(Closure.wrap(this.body), true);
      if (this.variable) {
        klass = new Assign(this.variable, klass);
      }</pre></td></tr><tr valign="top"><td><pre>937,1163,compile</pre></td><td><pre>    klass.compile o

#### Assign

# The **Assign** is used to assign a local variable to value, or to set the
# property of an object -- including within object literals.</pre></td><td><pre>      return klass.compile(o);
    };
    return Class;
  })();</pre></td></tr><tr valign="top"><td><pre>943,1167,exports</pre></td><td><pre>exports.Assign = class Assign extends Base</pre></td><td><pre>  exports.Assign = Assign = (function() {
    __extends(Assign, Base);</pre></td></tr><tr valign="top"><td><pre>944,1169,variable</pre></td><td><pre>  constructor: (@variable, @value, @context, options) -&gt;
    @param = options and options.param</pre></td><td><pre>    function Assign(variable, value, context, options) {
      this.variable = variable;
      this.value = value;
      this.context = context;
      this.param = options &amp;&amp; options.param;</pre></td></tr><tr valign="top"><td><pre>946,1174,subpattern</pre></td><td><pre>    @subpattern = options and options.subpattern
</pre></td><td><pre>      this.subpattern = options &amp;&amp; options.subpattern;
    }</pre></td></tr><tr valign="top"><td><pre>948,1176,children</pre></td><td><pre>  children: ['variable', 'value']
</pre></td><td><pre>    Assign.prototype.children = ['variable', 'value'];</pre></td></tr><tr valign="top"><td><pre>950,1177,isStatement</pre></td><td><pre>  isStatement: (o) -&gt;</pre></td><td><pre>    Assign.prototype.isStatement = function(o) {</pre></td></tr><tr valign="top"><td><pre>951,1178,level</pre></td><td><pre>    o?.level is LEVEL_TOP and @context? and "?" in @context
</pre></td><td><pre>      return (o != null ? o.level : void 0) === LEVEL_TOP &amp;&amp; (this.context != null) &amp;
    };</pre></td></tr><tr valign="top"><td><pre>953,1180,assigns</pre></td><td><pre>  assigns: (name) -&gt;
    @[if @context is 'object' then 'value' else 'variable'].assigns name
</pre></td><td><pre>    Assign.prototype.assigns = function(name) {
      return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
    };</pre></td></tr><tr valign="top"><td><pre>956,1183,unfoldSoak</pre></td><td><pre>  unfoldSoak: (o) -&gt;
    unfoldSoak o, this, 'variable'

  # Compile an assignment, delegating to `compilePatternMatch` or
  # `compileSplice` if appropriate. Keep track of the name of the base object
  # we've been assigned to, for correct internal references. If the variable
  # has not been seen yet within the current scope, declare it.</pre></td><td><pre>    Assign.prototype.unfoldSoak = function(o) {
      return unfoldSoak(o, this, 'variable');
    };</pre></td></tr><tr valign="top"><td><pre>963,1186,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Assign.prototype.compileNode = function(o) {
      var isValue, match, name, val, varBase, _ref2, _ref3, _ref4, _ref5;</pre></td></tr><tr valign="top"><td><pre>964,1188,isValue</pre></td><td><pre>    if isValue = @variable instanceof Value
      return @compilePatternMatch o if @variable.isArray() or @variable.isObject()</pre></td><td><pre>      if (isValue = this.variable instanceof Value) {
        if (this.variable.isArray() || this.variable.isObject()) {
          return this.compilePatternMatch(o);
        }</pre></td></tr><tr valign="top"><td><pre>966,1192,isSplice</pre></td><td><pre>      return @compileSplice       o if @variable.isSplice()</pre></td><td><pre>        if (this.variable.isSplice()) {
          return this.compileSplice(o);
        }</pre></td></tr><tr valign="top"><td><pre>967,1195,context</pre></td><td><pre>      return @compileConditional  o if @context in ['||=', '&amp;&amp;=', '?=']</pre></td><td><pre>        if ((_ref2 = this.context) === '||=' || _ref2 === '&amp;&amp;=' || _ref2 === '?=') {
          return this.compileConditional(o);
        }
      }</pre></td></tr><tr valign="top"><td><pre>968,1199,name</pre></td><td><pre>    name = @variable.compile o, LEVEL_LIST</pre></td><td><pre>      name = this.variable.compile(o, LEVEL_LIST);</pre></td></tr><tr valign="top"><td><pre>969,1200,context</pre></td><td><pre>    unless @context</pre></td><td><pre>      if (!this.context) {</pre></td></tr><tr valign="top"><td><pre>970,1201,varBase</pre></td><td><pre>      unless (varBase = @variable.unwrapAll()).isAssignable()</pre></td><td><pre>        if (!(varBase = this.variable.unwrapAll()).isAssignable()) {</pre></td></tr><tr valign="top"><td><pre>971,1202,throw</pre></td><td><pre>        throw SyntaxError "\"#{ @variable.compile o }\" cannot be assigned."</pre></td><td><pre>          throw SyntaxError("\"" + (this.variable.compile(o)) + "\" cannot be assigne
        }</pre></td></tr><tr valign="top"><td><pre>972,1204,varBase</pre></td><td><pre>      unless varBase.hasProperties?()</pre></td><td><pre>        if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() :</pre></td></tr><tr valign="top"><td><pre>973,1205,param</pre></td><td><pre>        if @param</pre></td><td><pre>          if (this.param) {</pre></td></tr><tr valign="top"><td><pre>974,1206,scope</pre></td><td><pre>          o.scope.add name, 'var'
        else
          o.scope.find name</pre></td><td><pre>            o.scope.add(name, 'var');
          } else {
            o.scope.find(name);
          }
        }
      }</pre></td></tr><tr valign="top"><td><pre>977,1212,value</pre></td><td><pre>    if @value instanceof Code and match = METHOD_DEF.exec name
      @value.klass = match[1] if match[1]
      @value.name  = match[2] ? match[3] ? match[4] ? match[5]</pre></td><td><pre>      if (this.value instanceof Code &amp;&amp; (match = METHOD_DEF.exec(name))) {
        if (match[1]) {
          this.value.klass = match[1];
        }
        this.value.name = (_ref3 = (_ref4 = (_ref5 = match[2]) != null ? _ref5 : matc
      }</pre></td></tr><tr valign="top"><td><pre>980,1218,val</pre></td><td><pre>    val = @value.compile o, LEVEL_LIST
    return "#{name}: #{val}" if @context is 'object'
    val = name + " #{ @context or '=' } " + val
    if o.level &lt;= LEVEL_LIST then val else "(#{val})"

  # Brief implementation of recursive pattern matching, when assigning array or
  # object literals to a value. Peeks at their properties to assign inner names.
  # See the [ECMAScript Harmony Wiki](http://wiki.ecmascript.org/doku.php?id=harmony:
  # for details.</pre></td><td><pre>      val = this.value.compile(o, LEVEL_LIST);
      if (this.context === 'object') {
        return "" + name + ": " + val;
      }
      val = name + (" " + (this.context || '=') + " ") + val;
      if (o.level &lt;= LEVEL_LIST) {
        return val;
      } else {
        return "(" + val + ")";
      }
    };</pre></td></tr><tr valign="top"><td><pre>989,1229,compilePatternMatch</pre></td><td><pre>  compilePatternMatch: (o) -&gt;</pre></td><td><pre>    Assign.prototype.compilePatternMatch = function(o) {
      var acc, assigns, code, i, idx, isObject, ivar, name, obj, objects, olen, ref, </pre></td></tr><tr valign="top"><td><pre>990,1231,top</pre></td><td><pre>    top       = o.level is LEVEL_TOP</pre></td><td><pre>      top = o.level === LEVEL_TOP;</pre></td></tr><tr valign="top"><td><pre>991,1232,value</pre></td><td><pre>    {value}   = this</pre></td><td><pre>      value = this.value;</pre></td></tr><tr valign="top"><td><pre>992,1233,objects</pre></td><td><pre>    {objects} = @variable.base
    unless olen = objects.length</pre></td><td><pre>      objects = this.variable.base.objects;
      if (!(olen = objects.length)) {</pre></td></tr><tr valign="top"><td><pre>994,1235,code</pre></td><td><pre>      code = value.compile o</pre></td><td><pre>        code = value.compile(o);</pre></td></tr><tr valign="top"><td><pre>995,1236,level</pre></td><td><pre>      return if o.level &gt;= LEVEL_OP then "(#{code})" else code</pre></td><td><pre>        if (o.level &gt;= LEVEL_OP) {
          return "(" + code + ")";
        } else {
          return code;
        }
      }</pre></td></tr><tr valign="top"><td><pre>996,1242,isObject</pre></td><td><pre>    isObject = @variable.isObject()</pre></td><td><pre>      isObject = this.variable.isObject();</pre></td></tr><tr valign="top"><td><pre>997,1243,top</pre></td><td><pre>    if top and olen is 1 and (obj = objects[0]) not instanceof Splat
      # Unroll simplest cases: `{v} = x` -&gt; `v = x.v`
      if obj instanceof Assign</pre></td><td><pre>      if (top &amp;&amp; olen === 1 &amp;&amp; !((obj = objects[0]) instanceof Splat)) {
        if (obj instanceof Assign) {</pre></td></tr><tr valign="top"><td><pre>1000,1245,variable</pre></td><td><pre>        {variable: {base: idx}, value: obj} = obj
      else
        if obj.base instanceof Parens
          [obj, idx] = new Value(obj.unwrapAll()).cacheReference o
        else</pre></td><td><pre>          _ref2 = obj, idx = _ref2.variable.base, obj = _ref2.value;
        } else {
          if (obj.base instanceof Parens) {
            _ref3 = new Value(obj.unwrapAll()).cacheReference(o), obj = _ref3[0], idx
          } else {</pre></td></tr><tr valign="top"><td><pre>1005,1250,isObject</pre></td><td><pre>          idx = if isObject
            if obj.this then obj.properties[0].name else obj
          else
            new Literal 0
      acc   = IDENTIFIER.test idx.unwrap().value or 0</pre></td><td><pre>            idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal
          }
        }
        acc = IDENTIFIER.test(idx.unwrap().value || 0);</pre></td></tr><tr valign="top"><td><pre>1010,1254,Value</pre></td><td><pre>      value = new Value value
      value.properties.push new (if acc then Access else Index) idx</pre></td><td><pre>        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));</pre></td></tr><tr valign="top"><td><pre>1012,1256,obj</pre></td><td><pre>      if obj.unwrap().value in ['arguments','eval'].concat RESERVED</pre></td><td><pre>        if (_ref4 = obj.unwrap().value, __indexOf.call(['arguments', 'eval'].concat(R</pre></td></tr><tr valign="top"><td><pre>1013,1257,throw</pre></td><td><pre>        throw new SyntaxError "assignment to a reserved word: #{obj.compile o} = #{va
      return new Assign(obj, value, null, param: @param).compile o, LEVEL_TOP</pre></td><td><pre>          throw new SyntaxError("assignment to a reserved word: " + (obj.compile(o)) 
        }
        return new Assign(obj, value, null, {
          param: this.param
        }).compile(o, LEVEL_TOP);
      }</pre></td></tr><tr valign="top"><td><pre>1015,1263,vvar</pre></td><td><pre>    vvar    = value.compile o, LEVEL_LIST</pre></td><td><pre>      vvar = value.compile(o, LEVEL_LIST);</pre></td></tr><tr valign="top"><td><pre>1016,1264,assigns</pre></td><td><pre>    assigns = []</pre></td><td><pre>      assigns = [];</pre></td></tr><tr valign="top"><td><pre>1017,1265,splat</pre></td><td><pre>    splat   = false</pre></td><td><pre>      splat = false;</pre></td></tr><tr valign="top"><td><pre>1018,1266,IDENTIFIER</pre></td><td><pre>    if not IDENTIFIER.test(vvar) or @variable.assigns(vvar)
      assigns.push "#{ ref = o.scope.freeVariable 'ref' } = #{vvar}"
      vvar = ref</pre></td><td><pre>      if (!IDENTIFIER.test(vvar) || this.variable.assigns(vvar)) {
        assigns.push("" + (ref = o.scope.freeVariable('ref')) + " = " + vvar);
        vvar = ref;
      }</pre></td></tr><tr valign="top"><td><pre>1021,1270,objects</pre></td><td><pre>    for obj, i in objects
      # A regular array pattern-match.</pre></td><td><pre>      for (i = 0, _len = objects.length; i &lt; _len; i++) {
        obj = objects[i];</pre></td></tr><tr valign="top"><td><pre>1023,1272,idx</pre></td><td><pre>      idx = i</pre></td><td><pre>        idx = i;</pre></td></tr><tr valign="top"><td><pre>1024,1273,isObject</pre></td><td><pre>      if isObject</pre></td><td><pre>        if (isObject) {</pre></td></tr><tr valign="top"><td><pre>1025,1274,obj</pre></td><td><pre>        if obj instanceof Assign
          # A regular object pattern-match.
          {variable: {base: idx}, value: obj} = obj
        else
          # A shorthand `{a, b, @c} = val` pattern-match.
          if obj.base instanceof Parens</pre></td><td><pre>          if (obj instanceof Assign) {
            _ref5 = obj, idx = _ref5.variable.base, obj = _ref5.value;
          } else {
            if (obj.base instanceof Parens) {</pre></td></tr><tr valign="top"><td><pre>1031,1278,new</pre></td><td><pre>            [obj, idx] = new Value(obj.unwrapAll()).cacheReference o
          else
            idx = if obj.this then obj.properties[0].name else obj</pre></td><td><pre>              _ref6 = new Value(obj.unwrapAll()).cacheReference(o), obj = _ref6[0], i
            } else {
              idx = obj["this"] ? obj.properties[0].name : obj;
            }
          }
        }</pre></td></tr><tr valign="top"><td><pre>1034,1284,splat</pre></td><td><pre>      if not splat and obj instanceof Splat
        name = obj.name.unwrap().value
        obj = obj.unwrap()</pre></td><td><pre>        if (!splat &amp;&amp; obj instanceof Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();</pre></td></tr><tr valign="top"><td><pre>1037,1287,val</pre></td><td><pre>        val = "#{olen} &lt;= #{vvar}.length ? #{ utility 'slice' }.call(#{vvar}, #{i}"
        if rest = olen - i - 1</pre></td><td><pre>          val = "" + olen + " &lt;= " + vvar + ".length ? " + (utility('slice')) + ".cal
          if (rest = olen - i - 1) {</pre></td></tr><tr valign="top"><td><pre>1039,1289,ivar</pre></td><td><pre>          ivar = o.scope.freeVariable 'i'</pre></td><td><pre>            ivar = o.scope.freeVariable('i');</pre></td></tr><tr valign="top"><td><pre>1040,1290,val</pre></td><td><pre>          val += ", #{ivar} = #{vvar}.length - #{rest}) : (#{ivar} = #{i}, [])"
        else
          val += ") : []"</pre></td><td><pre>            val += ", " + ivar + " = " + vvar + ".length - " + rest + ") : (" + ivar 
          } else {
            val += ") : []";
          }</pre></td></tr><tr valign="top"><td><pre>1043,1294,new</pre></td><td><pre>        val   = new Literal val</pre></td><td><pre>          val = new Literal(val);</pre></td></tr><tr valign="top"><td><pre>1044,1295,splat</pre></td><td><pre>        splat = "#{ivar}++"
      else</pre></td><td><pre>          splat = "" + ivar + "++";
        } else {</pre></td></tr><tr valign="top"><td><pre>1046,1297,name</pre></td><td><pre>        name = obj.unwrap().value
        if obj instanceof Splat
          obj = obj.name.compile o</pre></td><td><pre>          name = obj.unwrap().value;
          if (obj instanceof Splat) {
            obj = obj.name.compile(o);</pre></td></tr><tr valign="top"><td><pre>1049,1300,throw</pre></td><td><pre>          throw new SyntaxError \
            "multiple splats are disallowed in an assignment: #{obj}..."</pre></td><td><pre>            throw new SyntaxError("multiple splats are disallowed in an assignment: "
          }</pre></td></tr><tr valign="top"><td><pre>1051,1302,typeof</pre></td><td><pre>        if typeof idx is 'number'
          idx = new Literal splat or idx</pre></td><td><pre>          if (typeof idx === 'number') {
            idx = new Literal(splat || idx);</pre></td></tr><tr valign="top"><td><pre>1053,1304,acc</pre></td><td><pre>          acc = no
        else
          acc = isObject and IDENTIFIER.test idx.unwrap().value or 0</pre></td><td><pre>            acc = false;
          } else {
            acc = isObject &amp;&amp; IDENTIFIER.test(idx.unwrap().value || 0);
          }</pre></td></tr><tr valign="top"><td><pre>1056,1308,val</pre></td><td><pre>        val = new Value new Literal(vvar), [new (if acc then Access else Index) idx]</pre></td><td><pre>          val = new Value(new Literal(vvar), [new (acc ? Access : Index)(idx)]);
        }</pre></td></tr><tr valign="top"><td><pre>1057,1310,name</pre></td><td><pre>      if name? and name in ['arguments','eval'].concat RESERVED</pre></td><td><pre>        if ((name != null) &amp;&amp; __indexOf.call(['arguments', 'eval'].concat(RESERVED), </pre></td></tr><tr valign="top"><td><pre>1058,1311,throw</pre></td><td><pre>        throw new SyntaxError "assignment to a reserved word: #{obj.compile o} = #{va
      assigns.push new Assign(obj, val, null, param: @param, subpattern: yes).compile</pre></td><td><pre>          throw new SyntaxError("assignment to a reserved word: " + (obj.compile(o)) 
        }
        assigns.push(new Assign(obj, val, null, {
          param: this.param,
          subpattern: true
        }).compile(o, LEVEL_LIST));
      }</pre></td></tr><tr valign="top"><td><pre>1060,1318,top</pre></td><td><pre>    assigns.push vvar unless top or @subpattern</pre></td><td><pre>      if (!(top || this.subpattern)) {</pre></td></tr><tr valign="top"><td><pre>1061,1319,assigns</pre></td><td><pre>    code = assigns.join ', '</pre></td><td><pre>        assigns.push(vvar);
      }</pre></td></tr><tr valign="top"><td><pre>1062,1321,code</pre></td><td><pre>    if o.level &lt; LEVEL_LIST then code else "(#{code})"

  # When compiling a conditional assignment, take care to ensure that the
  # operands are only evaluated once, even though we have to reference them
  # more than once.</pre></td><td><pre>      code = assigns.join(', ');
      if (o.level &lt; LEVEL_LIST) {
        return code;
      } else {
        return "(" + code + ")";
      }
    };</pre></td></tr><tr valign="top"><td><pre>1067,1328,compileConditional</pre></td><td><pre>  compileConditional: (o) -&gt;</pre></td><td><pre>    Assign.prototype.compileConditional = function(o) {
      var left, rite, _ref2;</pre></td></tr><tr valign="top"><td><pre>1068,1330,left</pre></td><td><pre>    [left, rite] = @variable.cacheReference o</pre></td><td><pre>      _ref2 = this.variable.cacheReference(o), left = _ref2[0], rite = _ref2[1];</pre></td></tr><tr valign="top"><td><pre>1069,1331,context</pre></td><td><pre>    if "?" in @context then o.isExistentialEquals = true
    new Op(@context[0...-1], left, new Assign(rite, @value, '=') ).compile o

  # Compile the assignment from an array splice literal, using JavaScript's
  # `Array#splice` method.</pre></td><td><pre>      if (__indexOf.call(this.context, "?") &gt;= 0) {
        o.isExistentialEquals = true;
      }
      return new Op(this.context.slice(0, -1), left, new Assign(rite, this.value, '='
    };</pre></td></tr><tr valign="top"><td><pre>1074,1336,compileSplice</pre></td><td><pre>  compileSplice: (o) -&gt;</pre></td><td><pre>    Assign.prototype.compileSplice = function(o) {
      var code, exclusive, from, fromDecl, fromRef, name, to, valDef, valRef, _ref2, </pre></td></tr><tr valign="top"><td><pre>1075,1338,range</pre></td><td><pre>    {range: {from, to, exclusive}} = @variable.properties.pop()
    name = @variable.compile o
    [fromDecl, fromRef] = from?.cache(o, LEVEL_OP) or ['0', '0']
    if to</pre></td><td><pre>      _ref2 = this.variable.properties.pop().range, from = _ref2.from, to = _ref2.to,
      name = this.variable.compile(o);
      _ref3 = (from != null ? from.cache(o, LEVEL_OP) : void 0) || ['0', '0'], fromDe
      if (to) {</pre></td></tr><tr valign="top"><td><pre>1079,1342,isSimpleNumber</pre></td><td><pre>      if from?.isSimpleNumber() and to.isSimpleNumber()</pre></td><td><pre>        if ((from != null ? from.isSimpleNumber() : void 0) &amp;&amp; to.isSimpleNumber()) {</pre></td></tr><tr valign="top"><td><pre>1080,1343,compile</pre></td><td><pre>        to = +to.compile(o) - +fromRef</pre></td><td><pre>          to = +to.compile(o) - +fromRef;</pre></td></tr><tr valign="top"><td><pre>1081,1344,exclusive</pre></td><td><pre>        to += 1 unless exclusive
      else</pre></td><td><pre>          if (!exclusive) {
            to += 1;
          }
        } else {</pre></td></tr><tr valign="top"><td><pre>1083,1348,compile</pre></td><td><pre>        to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef</pre></td><td><pre>          to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;</pre></td></tr><tr valign="top"><td><pre>1084,1349,exclusive</pre></td><td><pre>        to += ' + 1' unless exclusive
    else</pre></td><td><pre>          if (!exclusive) {
            to += ' + 1';
          }
        }
      } else {</pre></td></tr><tr valign="top"><td><pre>1086,1354,9e9</pre></td><td><pre>      to = "9e9"</pre></td><td><pre>        to = "9e9";
      }</pre></td></tr><tr valign="top"><td><pre>1087,1356,valDef</pre></td><td><pre>    [valDef, valRef] = @value.cache o, LEVEL_LIST</pre></td><td><pre>      _ref4 = this.value.cache(o, LEVEL_LIST), valDef = _ref4[0], valRef = _ref4[1];</pre></td></tr><tr valign="top"><td><pre>1088,1357,code</pre></td><td><pre>    code = "[].splice.apply(#{name}, [#{fromDecl}, #{to}].concat(#{valDef})), #{valRe</pre></td><td><pre>      code = "[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat(" +</pre></td></tr><tr valign="top"><td><pre>1089,1358,level</pre></td><td><pre>    if o.level &gt; LEVEL_TOP then "(#{code})" else code

#### Code

# A function definition. This is the only node that creates a new Scope.
# When for the purposes of walking the contents of a function body, the Code
# has no *children* -- they're within the inner scope.</pre></td><td><pre>      if (o.level &gt; LEVEL_TOP) {
        return "(" + code + ")";
      } else {
        return code;
      }
    };
    return Assign;
  })();</pre></td></tr><tr valign="top"><td><pre>1096,1366,exports</pre></td><td><pre>exports.Code = class Code extends Base</pre></td><td><pre>  exports.Code = Code = (function() {
    __extends(Code, Base);</pre></td></tr><tr valign="top"><td><pre>1097,1368,params</pre></td><td><pre>  constructor: (params, body, tag) -&gt;
    @params  = params or []
    @body    = body or new Block
    @bound   = tag is 'boundfunc'</pre></td><td><pre>    function Code(params, body, tag) {
      this.params = params || [];
      this.body = body || new Block;
      this.bound = tag === 'boundfunc';
      if (this.bound) {</pre></td></tr><tr valign="top"><td><pre>1101,1373,context</pre></td><td><pre>    @context = '_this' if @bound
</pre></td><td><pre>        this.context = '_this';
      }
    }</pre></td></tr><tr valign="top"><td><pre>1103,1376,children</pre></td><td><pre>  children: ['params', 'body']
</pre></td><td><pre>    Code.prototype.children = ['params', 'body'];</pre></td></tr><tr valign="top"><td><pre>1105,1377,isStatement</pre></td><td><pre>  isStatement: -&gt; !!@ctor
</pre></td><td><pre>    Code.prototype.isStatement = function() {
      return !!this.ctor;
    };</pre></td></tr><tr valign="top"><td><pre>1107,1380,jumps</pre></td><td><pre>  jumps: NO

  # Compilation creates a new scope unless explicitly asked to share with the
  # outer scope. Handles splat parameters in the parameter list by peeking at
  # the JavaScript `arguments` object. If the function is bound with the `=&gt;`
  # arrow, generates a wrapper that saves the current value of `this` through
  # a closure.</pre></td><td><pre>    Code.prototype.jumps = NO;</pre></td></tr><tr valign="top"><td><pre>1114,1381,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Code.prototype.compileNode = function(o) {
      var code, exprs, i, idt, lit, p, param, ref, splats, v, val, vars, wasEmpty, _i</pre></td></tr><tr valign="top"><td><pre>1115,1383,scope</pre></td><td><pre>    o.scope         = new Scope o.scope, @body, this
    o.scope.shared  = del(o, 'sharedScope')</pre></td><td><pre>      o.scope = new Scope(o.scope, this.body, this);
      o.scope.shared = del(o, 'sharedScope');</pre></td></tr><tr valign="top"><td><pre>1117,1385,indent</pre></td><td><pre>    o.indent        += TAB</pre></td><td><pre>      o.indent += TAB;</pre></td></tr><tr valign="top"><td><pre>1118,1386,delete</pre></td><td><pre>    delete o.bare</pre></td><td><pre>      delete o.bare;</pre></td></tr><tr valign="top"><td><pre>1119,1387,vars</pre></td><td><pre>    vars   = []</pre></td><td><pre>      vars = [];</pre></td></tr><tr valign="top"><td><pre>1120,1388,exprs</pre></td><td><pre>    exprs  = []</pre></td><td><pre>      exprs = [];</pre></td></tr><tr valign="top"><td><pre>1121,1389,params</pre></td><td><pre>    for param in @params when param.splat
      o.scope.add p.name.value, 'var', yes for p in @params when p.name.value</pre></td><td><pre>      _ref2 = this.params;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        param = _ref2[_i];
        if (param.splat) {
          _ref3 = this.params;
          for (_j = 0, _len2 = _ref3.length; _j &lt; _len2; _j++) {
            p = _ref3[_j];
            if (p.name.value) {
              o.scope.add(p.name.value, 'var', true);
            }
          }</pre></td></tr><tr valign="top"><td><pre>1123,1400,splats</pre></td><td><pre>      splats = new Assign new Value(new Arr(p.asReference o for p in @params)),
                          new Value new Literal 'arguments'</pre></td><td><pre>          splats = new Assign(new Value(new Arr((function() {
            var _k, _len3, _ref4, _results;
            _ref4 = this.params;
            _results = [];
            for (_k = 0, _len3 = _ref4.length; _k &lt; _len3; _k++) {
              p = _ref4[_k];
              _results.push(p.asReference(o));
            }
            return _results;
          }).call(this))), new Value(new Literal('arguments')));</pre></td></tr><tr valign="top"><td><pre>1125,1410,break</pre></td><td><pre>      break</pre></td><td><pre>          break;
        }
      }</pre></td></tr><tr valign="top"><td><pre>1126,1413,params</pre></td><td><pre>    for param in @params</pre></td><td><pre>      _ref4 = this.params;
      for (_k = 0, _len3 = _ref4.length; _k &lt; _len3; _k++) {</pre></td></tr><tr valign="top"><td><pre>1127,1415,param</pre></td><td><pre>      if param.isComplex()
        val = ref = param.asReference o</pre></td><td><pre>        param = _ref4[_k];
        if (param.isComplex()) {
          val = ref = param.asReference(o);</pre></td></tr><tr valign="top"><td><pre>1129,1418,value</pre></td><td><pre>        val = new Op '?', ref, param.value if param.value
        exprs.push new Assign new Value(param.name), val, '=', param: yes
      else</pre></td><td><pre>          if (param.value) {</pre></td></tr><tr valign="top"><td><pre>1132,1419,ref</pre></td><td><pre>        ref = param
        if param.value
          lit = new Literal ref.name.value + ' == null'
          val = new Assign new Value(param.name), param.value, '='</pre></td><td><pre>            val = new Op('?', ref, param.value);
          }</pre></td></tr><tr valign="top"><td><pre>1136,1421,exprs</pre></td><td><pre>          exprs.push new If lit, val
      vars.push ref unless splats</pre></td><td><pre>          exprs.push(new Assign(new Value(param.name), val, '=', {
            param: true
          }));
        } else {
          ref = param;
          if (param.value) {
            lit = new Literal(ref.name.value + ' == null');
            val = new Assign(new Value(param.name), param.value, '=');
            exprs.push(new If(lit, val));
          }
        }
        if (!splats) {
          vars.push(ref);
        }
      }</pre></td></tr><tr valign="top"><td><pre>1138,1436,wasEmpty</pre></td><td><pre>    wasEmpty = @body.isEmpty()</pre></td><td><pre>      wasEmpty = this.body.isEmpty();</pre></td></tr><tr valign="top"><td><pre>1139,1437,splats</pre></td><td><pre>    exprs.unshift splats if splats</pre></td><td><pre>      if (splats) {</pre></td></tr><tr valign="top"><td><pre>1140,1438,unshift</pre></td><td><pre>    @body.expressions.unshift exprs... if exprs.length
    o.scope.parameter vars[i] = v.compile o for v, i in vars unless splats</pre></td><td><pre>        exprs.unshift(splats);
      }
      if (exprs.length) {</pre></td></tr><tr valign="top"><td><pre>1142,1441,body</pre></td><td><pre>    @body.makeReturn() unless wasEmpty or @noReturn</pre></td><td><pre>        (_ref5 = this.body.expressions).unshift.apply(_ref5, exprs);
      }
      if (!splats) {
        for (i = 0, _len4 = vars.length; i &lt; _len4; i++) {
          v = vars[i];
          o.scope.parameter(vars[i] = v.compile(o));
        }
      }
      if (!(wasEmpty || this.noReturn)) {
        this.body.makeReturn();
      }</pre></td></tr><tr valign="top"><td><pre>1143,1452,bound</pre></td><td><pre>    if @bound
      if o.scope.parent.method?.bound</pre></td><td><pre>      if (this.bound) {
        if ((_ref6 = o.scope.parent.method) != null ? _ref6.bound : void 0) {</pre></td></tr><tr valign="top"><td><pre>1145,1454,context</pre></td><td><pre>        @bound = o.scope.parent.method.context
      else
        o.scope.parent.assign '_this', 'this'</pre></td><td><pre>          this.bound = o.scope.parent.method.context;
        } else {
          o.scope.parent.assign('_this', 'this');
        }
      }</pre></td></tr><tr valign="top"><td><pre>1148,1459,idt</pre></td><td><pre>    idt   = o.indent</pre></td><td><pre>      idt = o.indent;</pre></td></tr><tr valign="top"><td><pre>1149,1460,code</pre></td><td><pre>    code  = 'function'
    code  += ' ' + @name if @ctor</pre></td><td><pre>      code = 'function';
      if (this.ctor) {
        code += ' ' + this.name;
      }</pre></td></tr><tr valign="top"><td><pre>1151,1464,vars</pre></td><td><pre>    code  += '(' + vars.join(', ') + ') {'
    code  += "\n#{ @body.compileWithDeclarations o }\n#{@tab}" unless @body.isEmpty()
    code  += '}'</pre></td><td><pre>      code += '(' + vars.join(', ') + ') {';
      if (!this.body.isEmpty()) {</pre></td></tr><tr valign="top"><td><pre>1154,1466,tab</pre></td><td><pre>    return @tab + code if @ctor</pre></td><td><pre>        code += "\n" + (this.body.compileWithDeclarations(o)) + "\n" + this.tab;
      }
      code += '}';
      if (this.ctor) {
        return this.tab + code;
      }</pre></td></tr><tr valign="top"><td><pre>1155,1472,front</pre></td><td><pre>    if @front or (o.level &gt;= LEVEL_ACCESS) then "(#{code})" else code

  # Short-circuit `traverseChildren` method to prevent it from crossing scope boundar
  # unless `crossScope` is `true`.</pre></td><td><pre>      if (this.front || (o.level &gt;= LEVEL_ACCESS)) {
        return "(" + code + ")";
      } else {
        return code;
      }
    };</pre></td></tr><tr valign="top"><td><pre>1159,1478,traverseChildren</pre></td><td><pre>  traverseChildren: (crossScope, func) -&gt;
    super(crossScope, func) if crossScope

#### Param

# A parameter in a function definition. Beyond a typical Javascript parameter,
# these parameters can also attach themselves to the context of the function,
# as well as be a splat, gathering up a group of parameters into an array.</pre></td><td><pre>    Code.prototype.traverseChildren = function(crossScope, func) {
      if (crossScope) {
        return Code.__super__.traverseChildren.call(this, crossScope, func);
      }
    };
    return Code;
  })();</pre></td></tr><tr valign="top"><td><pre>1167,1485,exports</pre></td><td><pre>exports.Param = class Param extends Base</pre></td><td><pre>  exports.Param = Param = (function() {
    __extends(Param, Base);</pre></td></tr><tr valign="top"><td><pre>1168,1487,name</pre></td><td><pre>  constructor: (@name, @value, @splat) -&gt;

  children: ['name', 'value']
</pre></td><td><pre>    function Param(name, value, splat) {
      this.name = name;
      this.value = value;
      this.splat = splat;
    }
    Param.prototype.children = ['name', 'value'];</pre></td></tr><tr valign="top"><td><pre>1172,1493,compile</pre></td><td><pre>  compile: (o) -&gt;
    @name.compile o, LEVEL_LIST
</pre></td><td><pre>    Param.prototype.compile = function(o) {
      return this.name.compile(o, LEVEL_LIST);
    };</pre></td></tr><tr valign="top"><td><pre>1175,1496,asReference</pre></td><td><pre>  asReference: (o) -&gt;</pre></td><td><pre>    Param.prototype.asReference = function(o) {
      var node;</pre></td></tr><tr valign="top"><td><pre>1176,1498,reference</pre></td><td><pre>    return @reference if @reference</pre></td><td><pre>      if (this.reference) {
        return this.reference;
      }</pre></td></tr><tr valign="top"><td><pre>1177,1501,node</pre></td><td><pre>    node = @name
    if node.this
      node = node.properties[0].name</pre></td><td><pre>      node = this.name;
      if (node["this"]) {
        node = node.properties[0].name;</pre></td></tr><tr valign="top"><td><pre>1180,1504,value</pre></td><td><pre>      node = new Literal '_' + node.value if node.value.reserved
    else if node.isComplex()</pre></td><td><pre>        if (node.value.reserved) {</pre></td></tr><tr valign="top"><td><pre>1182,1505,new</pre></td><td><pre>      node = new Literal o.scope.freeVariable 'arg'
    node = new Value node</pre></td><td><pre>          node = new Literal('_' + node.value);
        }
      } else if (node.isComplex()) {
        node = new Literal(o.scope.freeVariable('arg'));
      }
      node = new Value(node);</pre></td></tr><tr valign="top"><td><pre>1184,1511,splat</pre></td><td><pre>    node = new Splat node if @splat</pre></td><td><pre>      if (this.splat) {</pre></td></tr><tr valign="top"><td><pre>1185,1512,node</pre></td><td><pre>    @reference = node
</pre></td><td><pre>        node = new Splat(node);
      }
      return this.reference = node;
    };</pre></td></tr><tr valign="top"><td><pre>1187,1516,isComplex</pre></td><td><pre>  isComplex: -&gt;
    @name.isComplex()

#### Splat

# A splat, either as a parameter to a function, an argument to a call,
# or as part of a destructuring assignment.</pre></td><td><pre>    Param.prototype.isComplex = function() {
      return this.name.isComplex();
    };
    return Param;
  })();</pre></td></tr><tr valign="top"><td><pre>1194,1521,exports</pre></td><td><pre>exports.Splat = class Splat extends Base
</pre></td><td><pre>  exports.Splat = Splat = (function() {
    __extends(Splat, Base);</pre></td></tr><tr valign="top"><td><pre>1196,1523,children</pre></td><td><pre>  children: ['name']
</pre></td><td><pre>    Splat.prototype.children = ['name'];</pre></td></tr><tr valign="top"><td><pre>1198,1524,isAssignable</pre></td><td><pre>  isAssignable: YES
</pre></td><td><pre>    Splat.prototype.isAssignable = YES;</pre></td></tr><tr valign="top"><td><pre>1200,1525,name</pre></td><td><pre>  constructor: (name) -&gt;
    @name = if name.compile then name else new Literal name
</pre></td><td><pre>    function Splat(name) {
      this.name = name.compile ? name : new Literal(name);
    }</pre></td></tr><tr valign="top"><td><pre>1203,1528,assigns</pre></td><td><pre>  assigns: (name) -&gt;
    @name.assigns name
</pre></td><td><pre>    Splat.prototype.assigns = function(name) {
      return this.name.assigns(name);
    };</pre></td></tr><tr valign="top"><td><pre>1206,1531,compile</pre></td><td><pre>  compile: (o) -&gt;
    if @index? then @compileParam o else @name.compile o
    </pre></td><td><pre>    Splat.prototype.compile = function(o) {
      if (this.index != null) {
        return this.compileParam(o);
      } else {
        return this.name.compile(o);
      }
    };</pre></td></tr><tr valign="top"><td><pre>1209,1538,unwrap</pre></td><td><pre>  unwrap: -&gt; @name

  # Utility function that converts an arbitrary number of elements, mixed with
  # splats, to a proper array.</pre></td><td><pre>    Splat.prototype.unwrap = function() {
      return this.name;
    };</pre></td></tr><tr valign="top"><td><pre>1213,1541,compileSplattedArray</pre></td><td><pre>  @compileSplattedArray: (o, list, apply) -&gt;</pre></td><td><pre>    Splat.compileSplattedArray = function(o, list, apply) {
      var args, base, code, i, index, node, _len;</pre></td></tr><tr valign="top"><td><pre>1214,1543,index</pre></td><td><pre>    index = -1
    continue while (node = list[++index]) and node not instanceof Splat</pre></td><td><pre>      index = -1;
      while ((node = list[++index]) &amp;&amp; !(node instanceof Splat)) {
        continue;
      }</pre></td></tr><tr valign="top"><td><pre>1216,1547,length</pre></td><td><pre>    return '' if index &gt;= list.length
    if list.length is 1</pre></td><td><pre>      if (index &gt;= list.length) {
        return '';
      }
      if (list.length === 1) {</pre></td></tr><tr valign="top"><td><pre>1218,1551,code</pre></td><td><pre>      code = list[0].compile o, LEVEL_LIST
      return code if apply
      return "#{ utility 'slice' }.call(#{code})"
    args = list[index..]</pre></td><td><pre>        code = list[0].compile(o, LEVEL_LIST);
        if (apply) {
          return code;
        }
        return "" + (utility('slice')) + ".call(" + code + ")";
      }
      args = list.slice(index);
      for (i = 0, _len = args.length; i &lt; _len; i++) {</pre></td></tr><tr valign="top"><td><pre>1222,1559,node</pre></td><td><pre>    for node, i in args
      code = node.compile o, LEVEL_LIST
      args[i] = if node instanceof Splat
      then "#{ utility 'slice' }.call(#{code})"
      else "[#{code}]"</pre></td><td><pre>        node = args[i];
        code = node.compile(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? "" + (utility('slice')) + ".call(" + code +
      }
      if (index === 0) {</pre></td></tr><tr valign="top"><td><pre>1227,1564,concat</pre></td><td><pre>    return args[0] + ".concat(#{ args[1..].join ', ' })" if index is 0</pre></td><td><pre>        return args[0] + (".concat(" + (args.slice(1).join(', ')) + ")");
      }</pre></td></tr><tr valign="top"><td><pre>1228,1566,base</pre></td><td><pre>    base = (node.compile o, LEVEL_LIST for node in list[0...index])
    "[#{ base.join ', ' }].concat(#{ args.join ', ' })"

#### While

# A while loop, the only sort of low-level loop exposed by CoffeeScript. From
# it, all other loops can be manufactured. Useful in cases where you need more
# flexibility or more speed than a comprehension can provide.</pre></td><td><pre>      base = (function() {
        var _i, _len2, _ref2, _results;
        _ref2 = list.slice(0, index);
        _results = [];
        for (_i = 0, _len2 = _ref2.length; _i &lt; _len2; _i++) {
          node = _ref2[_i];
          _results.push(node.compile(o, LEVEL_LIST));
        }
        return _results;
      })();
      return "[" + (base.join(', ')) + "].concat(" + (args.join(', ')) + ")";
    };
    return Splat;
  })();</pre></td></tr><tr valign="top"><td><pre>1236,1580,exports</pre></td><td><pre>exports.While = class While extends Base</pre></td><td><pre>  exports.While = While = (function() {
    __extends(While, Base);</pre></td></tr><tr valign="top"><td><pre>1237,1582,condition</pre></td><td><pre>  constructor: (condition, options) -&gt;
    @condition = if options?.invert then condition.invert() else condition</pre></td><td><pre>    function While(condition, options) {
      this.condition = (options != null ? options.invert : void 0) ? condition.invert</pre></td></tr><tr valign="top"><td><pre>1239,1584,guard</pre></td><td><pre>    @guard     = options?.guard

  children: ['condition', 'guard', 'body']
</pre></td><td><pre>      this.guard = options != null ? options.guard : void 0;
    }
    While.prototype.children = ['condition', 'guard', 'body'];</pre></td></tr><tr valign="top"><td><pre>1243,1587,isStatement</pre></td><td><pre>  isStatement: YES
</pre></td><td><pre>    While.prototype.isStatement = YES;</pre></td></tr><tr valign="top"><td><pre>1245,1588,makeReturn</pre></td><td><pre>  makeReturn: (res) -&gt;
    if res
      super
    else</pre></td><td><pre>    While.prototype.makeReturn = function(res) {
      if (res) {
        return While.__super__.makeReturn.apply(this, arguments);
      } else {</pre></td></tr><tr valign="top"><td><pre>1249,1592,returns</pre></td><td><pre>      @returns = yes
      this
</pre></td><td><pre>        this.returns = true;
        return this;
      }
    };</pre></td></tr><tr valign="top"><td><pre>1252,1596,addBody</pre></td><td><pre>  addBody: (@body) -&gt;
    this
</pre></td><td><pre>    While.prototype.addBody = function(body) {
      this.body = body;
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>1255,1600,jumps</pre></td><td><pre>  jumps: -&gt;</pre></td><td><pre>    While.prototype.jumps = function() {
      var expressions, node, _i, _len;</pre></td></tr><tr valign="top"><td><pre>1256,1602,expressions</pre></td><td><pre>    {expressions} = @body
    return no unless expressions.length</pre></td><td><pre>      expressions = this.body.expressions;
      if (!expressions.length) {
        return false;
      }
      for (_i = 0, _len = expressions.length; _i &lt; _len; _i++) {</pre></td></tr><tr valign="top"><td><pre>1258,1607,node</pre></td><td><pre>    for node in expressions
      return node if node.jumps loop: yes
    no

  # The main difference from a JavaScript *while* is that the CoffeeScript
  # *while* can be used as a part of a larger expression -- while loops may
  # return an array containing the computed result of each iteration.</pre></td><td><pre>        node = expressions[_i];
        if (node.jumps({
          loop: true
        })) {
          return node;
        }
      }
      return false;
    };</pre></td></tr><tr valign="top"><td><pre>1265,1616,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    While.prototype.compileNode = function(o) {
      var body, code, rvar, set;</pre></td></tr><tr valign="top"><td><pre>1266,1618,indent</pre></td><td><pre>    o.indent += TAB</pre></td><td><pre>      o.indent += TAB;</pre></td></tr><tr valign="top"><td><pre>1267,1619,set</pre></td><td><pre>    set      = ''</pre></td><td><pre>      set = '';</pre></td></tr><tr valign="top"><td><pre>1268,1620,body</pre></td><td><pre>    {body}   = this
    if body.isEmpty()
      body = ''
    else</pre></td><td><pre>      body = this.body;
      if (body.isEmpty()) {
        body = '';
      } else {</pre></td></tr><tr valign="top"><td><pre>1272,1624,returns</pre></td><td><pre>      if @returns</pre></td><td><pre>        if (this.returns) {</pre></td></tr><tr valign="top"><td><pre>1273,1625,body</pre></td><td><pre>        body.makeReturn rvar = o.scope.freeVariable 'results'</pre></td><td><pre>          body.makeReturn(rvar = o.scope.freeVariable('results'));</pre></td></tr><tr valign="top"><td><pre>1274,1626,set</pre></td><td><pre>        set  = "#{@tab}#{rvar} = [];\n"</pre></td><td><pre>          set = "" + this.tab + rvar + " = [];\n";
        }</pre></td></tr><tr valign="top"><td><pre>1275,1628,guard</pre></td><td><pre>      if @guard</pre></td><td><pre>        if (this.guard) {</pre></td></tr><tr valign="top"><td><pre>1276,1629,body</pre></td><td><pre>        if body.expressions.length &gt; 1
          body.expressions.unshift new If (new Parens @guard).invert(), new Literal "
        else</pre></td><td><pre>          if (body.expressions.length &gt; 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Li
          } else {
            if (this.guard) {</pre></td></tr><tr valign="top"><td><pre>1279,1633,Block</pre></td><td><pre>          body = Block.wrap [new If @guard, body] if @guard
      body = "\n#{ body.compile o, LEVEL_TOP }\n#{@tab}"</pre></td><td><pre>              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }</pre></td></tr><tr valign="top"><td><pre>1281,1637,tab</pre></td><td><pre>    code = set + @tab + "while (#{ @condition.compile o, LEVEL_PAREN }) {#{body}}"</pre></td><td><pre>        body = "\n" + (body.compile(o, LEVEL_TOP)) + "\n" + this.tab;
      }
      code = set + this.tab + ("while (" + (this.condition.compile(o, LEVEL_PAREN)) +</pre></td></tr><tr valign="top"><td><pre>1282,1640,returns</pre></td><td><pre>    if @returns</pre></td><td><pre>      if (this.returns) {</pre></td></tr><tr valign="top"><td><pre>1283,1641,code</pre></td><td><pre>      code += "\n#{@tab}return #{rvar};"
    code

#### Op

# Simple Arithmetic and logical operations. Performs some conversion from
# CoffeeScript operations into their JavaScript equivalents.</pre></td><td><pre>        code += "\n" + this.tab + "return " + rvar + ";";
      }
      return code;
    };
    return While;
  })();</pre></td></tr><tr valign="top"><td><pre>1290,1647,exports</pre></td><td><pre>exports.Op = class Op extends Base</pre></td><td><pre>  exports.Op = Op = (function() {
    var CONVERSIONS, INVERSIONS;
    __extends(Op, Base);</pre></td></tr><tr valign="top"><td><pre>1291,1650,first</pre></td><td><pre>  constructor: (op, first, second, flip ) -&gt;
    return new In first, second if op is 'in'
    if op is 'do'</pre></td><td><pre>    function Op(op, first, second, flip) {
      var call;
      if (op === 'in') {
        return new In(first, second);
      }
      if (op === 'do') {</pre></td></tr><tr valign="top"><td><pre>1294,1656,Call</pre></td><td><pre>      call = new Call first, first.params or []
      call.do = yes
      return call
    if op is 'new'
      return first.newInstance() if first instanceof Call and not first.do and not fi</pre></td><td><pre>        call = new Call(first, first.params || []);
        call["do"] = true;
        return call;
      }
      if (op === 'new') {
        if (first instanceof Call &amp;&amp; !first["do"] &amp;&amp; !first.isNew) {
          return first.newInstance();
        }</pre></td></tr><tr valign="top"><td><pre>1299,1664,Code</pre></td><td><pre>      first = new Parens first   if first instanceof Code and first.bound or first.do</pre></td><td><pre>        if (first instanceof Code &amp;&amp; first.bound || first["do"]) {
          first = new Parens(first);
        }
      }</pre></td></tr><tr valign="top"><td><pre>1300,1668,operator</pre></td><td><pre>    @operator = CONVERSIONS[op] or op</pre></td><td><pre>      this.operator = CONVERSIONS[op] || op;</pre></td></tr><tr valign="top"><td><pre>1301,1669,first</pre></td><td><pre>    @first    = first</pre></td><td><pre>      this.first = first;</pre></td></tr><tr valign="top"><td><pre>1302,1670,second</pre></td><td><pre>    @second   = second</pre></td><td><pre>      this.second = second;</pre></td></tr><tr valign="top"><td><pre>1303,1671,flip</pre></td><td><pre>    @flip     = !!flip
    return this

  # The map of conversions from CoffeeScript to JavaScript symbols.</pre></td><td><pre>      this.flip = !!flip;
      return this;
    }</pre></td></tr><tr valign="top"><td><pre>1307,1674,CONVERSIONS</pre></td><td><pre>  CONVERSIONS =
    '==': '==='
    '!=': '!=='
    'of': 'in'

  # The map of invertible operators.</pre></td><td><pre>    CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in'
    };</pre></td></tr><tr valign="top"><td><pre>1313,1679,INVERSIONS</pre></td><td><pre>  INVERSIONS =
    '!==': '==='
    '===': '!=='
</pre></td><td><pre>    INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };</pre></td></tr><tr valign="top"><td><pre>1317,1683,children</pre></td><td><pre>  children: ['first', 'second']
</pre></td><td><pre>    Op.prototype.children = ['first', 'second'];</pre></td></tr><tr valign="top"><td><pre>1319,1684,isSimpleNumber</pre></td><td><pre>  isSimpleNumber: NO
</pre></td><td><pre>    Op.prototype.isSimpleNumber = NO;</pre></td></tr><tr valign="top"><td><pre>1321,1685,isUnary</pre></td><td><pre>  isUnary: -&gt;</pre></td><td><pre>    Op.prototype.isUnary = function() {</pre></td></tr><tr valign="top"><td><pre>1322,1686,second</pre></td><td><pre>    not @second
</pre></td><td><pre>      return !this.second;
    };</pre></td></tr><tr valign="top"><td><pre>1324,1688,isComplex</pre></td><td><pre>  isComplex: -&gt;
    not (@isUnary() and (@operator in ['+', '-'])) or @first.isComplex()

  # Am I capable of
  # [Python-style comparison chaining](http://docs.python.org/reference/expressions.h</pre></td><td><pre>    Op.prototype.isComplex = function() {
      var _ref2;
      return !(this.isUnary() &amp;&amp; ((_ref2 = this.operator) === '+' || _ref2 === '-')) 
    };</pre></td></tr><tr valign="top"><td><pre>1329,1692,isChainable</pre></td><td><pre>  isChainable: -&gt;</pre></td><td><pre>    Op.prototype.isChainable = function() {
      var _ref2;</pre></td></tr><tr valign="top"><td><pre>1330,1694,operator</pre></td><td><pre>    @operator in ['&lt;', '&gt;', '&gt;=', '&lt;=', '===', '!==']
</pre></td><td><pre>      return (_ref2 = this.operator) === '&lt;' || _ref2 === '&gt;' || _ref2 === '&gt;=' || _r
    };</pre></td></tr><tr valign="top"><td><pre>1332,1696,invert</pre></td><td><pre>  invert: -&gt;</pre></td><td><pre>    Op.prototype.invert = function() {
      var allInvertable, curr, fst, op, _ref2;</pre></td></tr><tr valign="top"><td><pre>1333,1698,isChainable</pre></td><td><pre>    if @isChainable() and @first.isChainable()</pre></td><td><pre>      if (this.isChainable() &amp;&amp; this.first.isChainable()) {</pre></td></tr><tr valign="top"><td><pre>1334,1699,allInvertable</pre></td><td><pre>      allInvertable = yes</pre></td><td><pre>        allInvertable = true;</pre></td></tr><tr valign="top"><td><pre>1335,1700,curr</pre></td><td><pre>      curr = this
      while curr and curr.operator</pre></td><td><pre>        curr = this;
        while (curr &amp;&amp; curr.operator) {</pre></td></tr><tr valign="top"><td><pre>1337,1702,allInvertable</pre></td><td><pre>        allInvertable and= (curr.operator of INVERSIONS)
        curr = curr.first
      return new Parens(this).invert() unless allInvertable
      curr = this
      while curr and curr.operator
        curr.invert = !curr.invert
        curr.operator = INVERSIONS[curr.operator]
        curr = curr.first
      this
    else if op = INVERSIONS[@operator]
      @operator = op</pre></td><td><pre>          allInvertable &amp;&amp; (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
        }
        if (!allInvertable) {
          return new Parens(this).invert();
        }
        curr = this;
        while (curr &amp;&amp; curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        return this;
      } else if (op = INVERSIONS[this.operator]) {
        this.operator = op;</pre></td></tr><tr valign="top"><td><pre>1348,1717,unwrap</pre></td><td><pre>      if @first.unwrap() instanceof Op
        @first.invert()
      this</pre></td><td><pre>        if (this.first.unwrap() instanceof Op) {
          this.first.invert();
        }
        return this;</pre></td></tr><tr valign="top"><td><pre>1351,1721,second</pre></td><td><pre>    else if @second</pre></td><td><pre>      } else if (this.second) {</pre></td></tr><tr valign="top"><td><pre>1352,1722,new</pre></td><td><pre>      new Parens(this).invert()</pre></td><td><pre>        return new Parens(this).invert();</pre></td></tr><tr valign="top"><td><pre>1353,1723,operator</pre></td><td><pre>    else if @operator is '!' and (fst = @first.unwrap()) instanceof Op and
                                  fst.operator in ['!', 'in', 'instanceof']
      fst
    else</pre></td><td><pre>      } else if (this.operator === '!' &amp;&amp; (fst = this.first.unwrap()) instanceof Op &amp;
        return fst;
      } else {</pre></td></tr><tr valign="top"><td><pre>1357,1726,new</pre></td><td><pre>      new Op '!', this
</pre></td><td><pre>        return new Op('!', this);
      }
    };</pre></td></tr><tr valign="top"><td><pre>1359,1729,unfoldSoak</pre></td><td><pre>  unfoldSoak: (o) -&gt;
    @operator in ['++', '--', 'delete'] and unfoldSoak o, this, 'first'
</pre></td><td><pre>    Op.prototype.unfoldSoak = function(o) {
      var _ref2;
      return ((_ref2 = this.operator) === '++' || _ref2 === '--' || _ref2 === 'delete
    };</pre></td></tr><tr valign="top"><td><pre>1362,1733,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;    </pre></td><td><pre>    Op.prototype.compileNode = function(o) {
      var code, isChain;</pre></td></tr><tr valign="top"><td><pre>1363,1735,isChain</pre></td><td><pre>    isChain = @isChainable() and @first.isChainable()
    # In chains, there's no need to wrap bare obj literals in parens, 
    # as the chained expression is wrapped.
    @first.front = @front unless isChain</pre></td><td><pre>      isChain = this.isChainable() &amp;&amp; this.first.isChainable();
      if (!isChain) {
        this.first.front = this.front;
      }</pre></td></tr><tr valign="top"><td><pre>1367,1739,isUnary</pre></td><td><pre>    return @compileUnary     o if @isUnary()</pre></td><td><pre>      if (this.isUnary()) {
        return this.compileUnary(o);
      }</pre></td></tr><tr valign="top"><td><pre>1368,1742,isChain</pre></td><td><pre>    return @compileChain     o if isChain</pre></td><td><pre>      if (isChain) {
        return this.compileChain(o);
      }</pre></td></tr><tr valign="top"><td><pre>1369,1745,operator</pre></td><td><pre>    return @compileExistence o if @operator is '?'
    code = @first.compile(o, LEVEL_OP) + ' ' + @operator + ' ' +</pre></td><td><pre>      if (this.operator === '?') {
        return this.compileExistence(o);
      }</pre></td></tr><tr valign="top"><td><pre>1371,1748,second</pre></td><td><pre>           @second.compile(o, LEVEL_OP)
    if o.level &lt;= LEVEL_OP then code else "(#{code})"

  # Mimic Python's chained comparisons when multiple comparison operators are
  # used sequentially. For example:
  #
  #     bin/coffee -e 'console.log 50 &lt; 65 &gt; 10'
  #     true</pre></td><td><pre>      code = this.first.compile(o, LEVEL_OP) + ' ' + this.operator + ' ' + this.secon
      if (o.level &lt;= LEVEL_OP) {
        return code;
      } else {
        return "(" + code + ")";
      }
    };</pre></td></tr><tr valign="top"><td><pre>1379,1755,compileChain</pre></td><td><pre>  compileChain: (o) -&gt;</pre></td><td><pre>    Op.prototype.compileChain = function(o) {
      var code, fst, shared, _ref2;</pre></td></tr><tr valign="top"><td><pre>1380,1757,first</pre></td><td><pre>    [@first.second, shared] = @first.second.cache o
    fst = @first.compile o, LEVEL_OP</pre></td><td><pre>      _ref2 = this.first.second.cache(o), this.first.second = _ref2[0], shared = _ref
      fst = this.first.compile(o, LEVEL_OP);</pre></td></tr><tr valign="top"><td><pre>1382,1759,code</pre></td><td><pre>    code = "#{fst} #{if @invert then '&amp;&amp;' else '||'} #{ shared.compile o } #{@operato
    "(#{code})"
</pre></td><td><pre>      code = "" + fst + " " + (this.invert ? '&amp;&amp;' : '||') + " " + (shared.compile(o))
      return "(" + code + ")";
    };</pre></td></tr><tr valign="top"><td><pre>1385,1762,compileExistence</pre></td><td><pre>  compileExistence: (o) -&gt;</pre></td><td><pre>    Op.prototype.compileExistence = function(o) {
      var fst, ref;</pre></td></tr><tr valign="top"><td><pre>1386,1764,first</pre></td><td><pre>    if @first.isComplex()</pre></td><td><pre>      if (this.first.isComplex()) {</pre></td></tr><tr valign="top"><td><pre>1387,1765,ref</pre></td><td><pre>      ref = new Literal o.scope.freeVariable 'ref'
      fst = new Parens new Assign ref, @first
    else
      fst = @first
      ref = fst</pre></td><td><pre>        ref = new Literal(o.scope.freeVariable('ref'));
        fst = new Parens(new Assign(ref, this.first));
      } else {
        fst = this.first;
        ref = fst;
      }</pre></td></tr><tr valign="top"><td><pre>1392,1771,Existence</pre></td><td><pre>    new If(new Existence(fst), ref, type: 'if').addElse(@second).compile o

  # Compile a unary **Op**.</pre></td><td><pre>      return new If(new Existence(fst), ref, {
        type: 'if'
      }).addElse(this.second).compile(o);
    };</pre></td></tr><tr valign="top"><td><pre>1395,1775,compileUnary</pre></td><td><pre>  compileUnary: (o) -&gt;</pre></td><td><pre>    Op.prototype.compileUnary = function(o) {
      var op, parts, plusMinus;</pre></td></tr><tr valign="top"><td><pre>1396,1777,parts</pre></td><td><pre>    parts = [op = @operator]</pre></td><td><pre>      parts = [op = this.operator];</pre></td></tr><tr valign="top"><td><pre>1397,1778,plusMinus</pre></td><td><pre>    plusMinus = op in ['+', '-']</pre></td><td><pre>      plusMinus = op === '+' || op === '-';</pre></td></tr><tr valign="top"><td><pre>1398,1779,new</pre></td><td><pre>    parts.push ' ' if op in ['new', 'typeof', 'delete'] or
                      plusMinus and @first instanceof Op and @first.operator is op
    if (plusMinus &amp;&amp; @first instanceof Op) or (op is 'new' and @first.isStatement o)</pre></td><td><pre>      if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus &amp;&amp; this.f
        parts.push(' ');
      }
      if ((plusMinus &amp;&amp; this.first instanceof Op) || (op === 'new' &amp;&amp; this.first.isSt</pre></td></tr><tr valign="top"><td><pre>1401,1783,Parens</pre></td><td><pre>      @first = new Parens @first 
    parts.push @first.compile o, LEVEL_OP</pre></td><td><pre>        this.first = new Parens(this.first);
      }
      parts.push(this.first.compile(o, LEVEL_OP));</pre></td></tr><tr valign="top"><td><pre>1403,1786,flip</pre></td><td><pre>    parts.reverse() if @flip</pre></td><td><pre>      if (this.flip) {</pre></td></tr><tr valign="top"><td><pre>1404,1787,parts</pre></td><td><pre>    parts.join ''
</pre></td><td><pre>        parts.reverse();
      }
      return parts.join('');
    };</pre></td></tr><tr valign="top"><td><pre>1406,1791,idt</pre></td><td><pre>  toString: (idt) -&gt;
    super idt, @constructor.name + ' ' + @operator

#### In</pre></td><td><pre>    Op.prototype.toString = function(idt) {
      return Op.__super__.toString.call(this, idt, this.constructor.name + ' ' + this
    };
    return Op;
  })();</pre></td></tr><tr valign="top"><td><pre>1410,1796,exports</pre></td><td><pre>exports.In = class In extends Base</pre></td><td><pre>  exports.In = In = (function() {
    __extends(In, Base);</pre></td></tr><tr valign="top"><td><pre>1411,1798,object</pre></td><td><pre>  constructor: (@object, @array) -&gt;

  children: ['object', 'array']
</pre></td><td><pre>    function In(object, array) {
      this.object = object;
      this.array = array;
    }
    In.prototype.children = ['object', 'array'];</pre></td></tr><tr valign="top"><td><pre>1415,1803,invert</pre></td><td><pre>  invert: NEGATE
</pre></td><td><pre>    In.prototype.invert = NEGATE;</pre></td></tr><tr valign="top"><td><pre>1417,1804,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    In.prototype.compileNode = function(o) {
      var hasSplat, obj, _i, _len, _ref2;</pre></td></tr><tr valign="top"><td><pre>1418,1806,array</pre></td><td><pre>    if @array instanceof Value and @array.isArray()
      for obj in @array.base.objects when obj instanceof Splat</pre></td><td><pre>      if (this.array instanceof Value &amp;&amp; this.array.isArray()) {
        _ref2 = this.array.base.objects;
        for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
          obj = _ref2[_i];
          if (obj instanceof Splat) {</pre></td></tr><tr valign="top"><td><pre>1420,1811,hasSplat</pre></td><td><pre>        hasSplat = yes</pre></td><td><pre>            hasSplat = true;</pre></td></tr><tr valign="top"><td><pre>1421,1812,break</pre></td><td><pre>        break
      # `compileOrTest` only if we have an array literal with no splats</pre></td><td><pre>            break;
          }
        }</pre></td></tr><tr valign="top"><td><pre>1423,1815,hasSplat</pre></td><td><pre>      return @compileOrTest o unless hasSplat</pre></td><td><pre>        if (!hasSplat) {
          return this.compileOrTest(o);
        }
      }</pre></td></tr><tr valign="top"><td><pre>1424,1819,compileLoopTest</pre></td><td><pre>    @compileLoopTest o
</pre></td><td><pre>      return this.compileLoopTest(o);
    };</pre></td></tr><tr valign="top"><td><pre>1426,1821,compileOrTest</pre></td><td><pre>  compileOrTest: (o) -&gt;
    return "#{!!@negated}" if @array.base.objects.length is 0</pre></td><td><pre>    In.prototype.compileOrTest = function(o) {
      var cmp, cnj, i, item, ref, sub, tests, _ref2, _ref3;
      if (this.array.base.objects.length === 0) {
        return "" + (!!this.negated);
      }</pre></td></tr><tr valign="top"><td><pre>1428,1826,sub</pre></td><td><pre>    [sub, ref] = @object.cache o, LEVEL_OP</pre></td><td><pre>      _ref2 = this.object.cache(o, LEVEL_OP), sub = _ref2[0], ref = _ref2[1];</pre></td></tr><tr valign="top"><td><pre>1429,1827,cmp</pre></td><td><pre>    [cmp, cnj] = if @negated then [' !== ', ' &amp;&amp; '] else [' === ', ' || ']</pre></td><td><pre>      _ref3 = this.negated ? [' !== ', ' &amp;&amp; '] : [' === ', ' || '], cmp = _ref3[0], c</pre></td></tr><tr valign="top"><td><pre>1430,1828,tests</pre></td><td><pre>    tests = for item, i in @array.base.objects</pre></td><td><pre>      tests = (function() {
        var _len, _ref4, _results;
        _ref4 = this.array.base.objects;
        _results = [];
        for (i = 0, _len = _ref4.length; i &lt; _len; i++) {</pre></td></tr><tr valign="top"><td><pre>1431,1833,item</pre></td><td><pre>      (if i then ref else sub) + cmp + item.compile o, LEVEL_ACCESS</pre></td><td><pre>          item = _ref4[i];
          _results.push((i ? ref : sub) + cmp + item.compile(o, LEVEL_ACCESS));
        }
        return _results;
      }).call(this);</pre></td></tr><tr valign="top"><td><pre>1432,1838,tests</pre></td><td><pre>    tests = tests.join cnj
    if o.level &lt; LEVEL_OP then tests else "(#{tests})"
</pre></td><td><pre>      tests = tests.join(cnj);
      if (o.level &lt; LEVEL_OP) {
        return tests;
      } else {
        return "(" + tests + ")";
      }
    };</pre></td></tr><tr valign="top"><td><pre>1435,1845,compileLoopTest</pre></td><td><pre>  compileLoopTest: (o) -&gt;</pre></td><td><pre>    In.prototype.compileLoopTest = function(o) {
      var code, ref, sub, _ref2;</pre></td></tr><tr valign="top"><td><pre>1436,1847,sub</pre></td><td><pre>    [sub, ref] = @object.cache o, LEVEL_LIST</pre></td><td><pre>      _ref2 = this.object.cache(o, LEVEL_LIST), sub = _ref2[0], ref = _ref2[1];</pre></td></tr><tr valign="top"><td><pre>1437,1848,code</pre></td><td><pre>    code = utility('indexOf') + ".call(#{ @array.compile o, LEVEL_LIST }, #{ref}) " +
           if @negated then '&lt; 0' else '&gt;= 0'
    return code if sub is ref
    code = sub + ', ' + code
    if o.level &lt; LEVEL_LIST then code else "(#{code})"
</pre></td><td><pre>      code = utility('indexOf') + (".call(" + (this.array.compile(o, LEVEL_LIST)) + "
      if (sub === ref) {
        return code;
      }
      code = sub + ', ' + code;
      if (o.level &lt; LEVEL_LIST) {
        return code;
      } else {
        return "(" + code + ")";
      }
    };</pre></td></tr><tr valign="top"><td><pre>1443,1859,idt</pre></td><td><pre>  toString: (idt) -&gt;
    super idt, @constructor.name + if @negated then '!' else ''

#### Try

# A classic *try/catch/finally* block.</pre></td><td><pre>    In.prototype.toString = function(idt) {
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.nega
    };
    return In;
  })();</pre></td></tr><tr valign="top"><td><pre>1449,1864,exports</pre></td><td><pre>exports.Try = class Try extends Base</pre></td><td><pre>  exports.Try = Try = (function() {
    __extends(Try, Base);</pre></td></tr><tr valign="top"><td><pre>1450,1866,attempt</pre></td><td><pre>  constructor: (@attempt, @error, @recovery, @ensure) -&gt;

  children: ['attempt', 'recovery', 'ensure']
</pre></td><td><pre>    function Try(attempt, error, recovery, ensure) {
      this.attempt = attempt;
      this.error = error;
      this.recovery = recovery;
      this.ensure = ensure;
    }
    Try.prototype.children = ['attempt', 'recovery', 'ensure'];</pre></td></tr><tr valign="top"><td><pre>1454,1873,isStatement</pre></td><td><pre>  isStatement: YES
</pre></td><td><pre>    Try.prototype.isStatement = YES;</pre></td></tr><tr valign="top"><td><pre>1456,1874,jumps</pre></td><td><pre>  jumps: (o) -&gt; @attempt.jumps(o) or @recovery?.jumps(o)
</pre></td><td><pre>    Try.prototype.jumps = function(o) {
      var _ref2;
      return this.attempt.jumps(o) || ((_ref2 = this.recovery) != null ? _ref2.jumps(
    };</pre></td></tr><tr valign="top"><td><pre>1458,1878,makeReturn</pre></td><td><pre>  makeReturn: (res) -&gt;
    @attempt  = @attempt .makeReturn res if @attempt</pre></td><td><pre>    Try.prototype.makeReturn = function(res) {
      if (this.attempt) {
        this.attempt = this.attempt.makeReturn(res);
      }</pre></td></tr><tr valign="top"><td><pre>1460,1882,recovery</pre></td><td><pre>    @recovery = @recovery.makeReturn res if @recovery
    this

  # Compilation is more or less as you would expect -- the *finally* clause
  # is optional, the *catch* is not.</pre></td><td><pre>      if (this.recovery) {
        this.recovery = this.recovery.makeReturn(res);
      }
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>1465,1887,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Try.prototype.compileNode = function(o) {
      var catchPart, ensurePart, errorPart, tryPart;</pre></td></tr><tr valign="top"><td><pre>1466,1889,indent</pre></td><td><pre>    o.indent  += TAB</pre></td><td><pre>      o.indent += TAB;</pre></td></tr><tr valign="top"><td><pre>1467,1890,errorPart</pre></td><td><pre>    errorPart = if @error then " (#{ @error.compile o }) " else ' '
    tryPart   = @attempt.compile o, LEVEL_TOP
    </pre></td><td><pre>      errorPart = this.error ? " (" + (this.error.compile(o)) + ") " : ' ';
      tryPart = this.attempt.compile(o, LEVEL_TOP);</pre></td></tr><tr valign="top"><td><pre>1470,1892,catchPart</pre></td><td><pre>    catchPart = if @recovery
      o.scope.add @error.value, 'param' unless o.scope.check @error.value
      " catch#{errorPart}{\n#{ @recovery.compile o, LEVEL_TOP }\n#{@tab}}"
    else unless @ensure or @recovery
      ' catch (_error) {}'
      </pre></td><td><pre>      catchPart = this.recovery ? (!o.scope.check(this.error.value) ? o.scope.add(thi</pre></td></tr><tr valign="top"><td><pre>1476,1893,ensurePart</pre></td><td><pre>    ensurePart = if @ensure then " finally {\n#{ @ensure.compile o, LEVEL_TOP }\n#{@t
      
    """#{@tab}try {
    #{tryPart}
    #{@tab}}#{ catchPart or '' }#{ensurePart}"""

#### Throw

# Simple node to throw an exception.</pre></td><td><pre>      ensurePart = this.ensure ? " finally {\n" + (this.ensure.compile(o, LEVEL_TOP))
      return "" + this.tab + "try {\n" + tryPart + "\n" + this.tab + "}" + (catchPart
    };
    return Try;
  })();</pre></td></tr><tr valign="top"><td><pre>1485,1898,exports</pre></td><td><pre>exports.Throw = class Throw extends Base</pre></td><td><pre>  exports.Throw = Throw = (function() {
    __extends(Throw, Base);</pre></td></tr><tr valign="top"><td><pre>1486,1900,expression</pre></td><td><pre>  constructor: (@expression) -&gt;

  children: ['expression']
</pre></td><td><pre>    function Throw(expression) {
      this.expression = expression;
    }
    Throw.prototype.children = ['expression'];</pre></td></tr><tr valign="top"><td><pre>1490,1904,isStatement</pre></td><td><pre>  isStatement: YES</pre></td><td><pre>    Throw.prototype.isStatement = YES;</pre></td></tr><tr valign="top"><td><pre>1491,1905,jumps</pre></td><td><pre>  jumps:       NO

  # A **Throw** is already a return, of sorts...</pre></td><td><pre>    Throw.prototype.jumps = NO;</pre></td></tr><tr valign="top"><td><pre>1494,1906,makeReturn</pre></td><td><pre>  makeReturn: THIS
</pre></td><td><pre>    Throw.prototype.makeReturn = THIS;</pre></td></tr><tr valign="top"><td><pre>1496,1907,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Throw.prototype.compileNode = function(o) {</pre></td></tr><tr valign="top"><td><pre>1497,1908,tab</pre></td><td><pre>    @tab + "throw #{ @expression.compile o };"

#### Existence

# Checks a variable for existence -- not *null* and not *undefined*. This is
# similar to `.nil?` in Ruby, and avoids having to consult a JavaScript truth
# table.</pre></td><td><pre>      return this.tab + ("throw " + (this.expression.compile(o)) + ";");
    };
    return Throw;
  })();</pre></td></tr><tr valign="top"><td><pre>1504,1912,exports</pre></td><td><pre>exports.Existence = class Existence extends Base</pre></td><td><pre>  exports.Existence = Existence = (function() {
    __extends(Existence, Base);</pre></td></tr><tr valign="top"><td><pre>1505,1914,expression</pre></td><td><pre>  constructor: (@expression) -&gt;

  children: ['expression']
</pre></td><td><pre>    function Existence(expression) {
      this.expression = expression;
    }
    Existence.prototype.children = ['expression'];</pre></td></tr><tr valign="top"><td><pre>1509,1918,invert</pre></td><td><pre>  invert: NEGATE
</pre></td><td><pre>    Existence.prototype.invert = NEGATE;</pre></td></tr><tr valign="top"><td><pre>1511,1919,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Existence.prototype.compileNode = function(o) {
      var cmp, cnj, code, _ref2;</pre></td></tr><tr valign="top"><td><pre>1512,1921,expression</pre></td><td><pre>    @expression.front = @front
    code = @expression.compile o, LEVEL_OP</pre></td><td><pre>      this.expression.front = this.front;
      code = this.expression.compile(o, LEVEL_OP);</pre></td></tr><tr valign="top"><td><pre>1514,1923,IDENTIFIER</pre></td><td><pre>    if IDENTIFIER.test(code) and not o.scope.check code</pre></td><td><pre>      if (IDENTIFIER.test(code) &amp;&amp; !o.scope.check(code)) {</pre></td></tr><tr valign="top"><td><pre>1515,1924,cmp</pre></td><td><pre>      [cmp, cnj] = if @negated then ['===', '||'] else ['!==', '&amp;&amp;']</pre></td><td><pre>        _ref2 = this.negated ? ['===', '||'] : ['!==', '&amp;&amp;'], cmp = _ref2[0], cnj = _</pre></td></tr><tr valign="top"><td><pre>1516,1925,code</pre></td><td><pre>      code = "typeof #{code} #{cmp} \"undefined\" #{cnj} #{code} #{cmp} null"
    else
      # do not use strict equality here; it will break existing code
      code = "#{code} #{if @negated then '==' else '!='} null"</pre></td><td><pre>        code = "typeof " + code + " " + cmp + " \"undefined\" " + cnj + " " + code + 
      } else {
        code = "" + code + " " + (this.negated ? '==' : '!=') + " null";
      }</pre></td></tr><tr valign="top"><td><pre>1520,1929,level</pre></td><td><pre>    if o.level &lt;= LEVEL_COND then code else "(#{code})"

#### Parens

# An extra set of parentheses, specified explicitly in the source. At one time
# we tried to clean up the results by detecting and removing redundant
# parentheses, but no longer -- you can put in as many as you please.
#
# Parentheses are a good way to force any statement to become an expression.</pre></td><td><pre>      if (o.level &lt;= LEVEL_COND) {
        return code;
      } else {
        return "(" + code + ")";
      }
    };
    return Existence;
  })();</pre></td></tr><tr valign="top"><td><pre>1529,1937,exports</pre></td><td><pre>exports.Parens = class Parens extends Base</pre></td><td><pre>  exports.Parens = Parens = (function() {
    __extends(Parens, Base);</pre></td></tr><tr valign="top"><td><pre>1530,1939,body</pre></td><td><pre>  constructor: (@body) -&gt;

  children: ['body']
</pre></td><td><pre>    function Parens(body) {
      this.body = body;
    }
    Parens.prototype.children = ['body'];</pre></td></tr><tr valign="top"><td><pre>1534,1943,unwrap</pre></td><td><pre>  unwrap    : -&gt; @body</pre></td><td><pre>    Parens.prototype.unwrap = function() {</pre></td></tr><tr valign="top"><td><pre>1535,1944,body</pre></td><td><pre>  isComplex : -&gt; @body.isComplex()
</pre></td><td><pre>      return this.body;
    };
    Parens.prototype.isComplex = function() {
      return this.body.isComplex();
    };</pre></td></tr><tr valign="top"><td><pre>1537,1949,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Parens.prototype.compileNode = function(o) {
      var bare, code, expr;</pre></td></tr><tr valign="top"><td><pre>1538,1951,expr</pre></td><td><pre>    expr = @body.unwrap()
    if expr instanceof Value and expr.isAtomic()</pre></td><td><pre>      expr = this.body.unwrap();
      if (expr instanceof Value &amp;&amp; expr.isAtomic()) {</pre></td></tr><tr valign="top"><td><pre>1540,1953,front</pre></td><td><pre>      expr.front = @front
      return expr.compile o</pre></td><td><pre>        expr.front = this.front;
        return expr.compile(o);
      }</pre></td></tr><tr valign="top"><td><pre>1542,1956,code</pre></td><td><pre>    code = expr.compile o, LEVEL_PAREN
    bare = o.level &lt; LEVEL_OP and (expr instanceof Op or expr instanceof Call or</pre></td><td><pre>      code = expr.compile(o, LEVEL_PAREN);</pre></td></tr><tr valign="top"><td><pre>1544,1957,For</pre></td><td><pre>      (expr instanceof For and expr.returns))
    if bare then code else "(#{code})"

#### For

# CoffeeScript's replacement for the *for* loop is our array and object
# comprehensions, that compile into *for* loops here. They also act as an
# expression, able to return the result of each filtered iteration.
#
# Unlike Python array comprehensions, they can be multi-line, and you can pass
# the current index of the loop as a second parameter. Unlike Ruby blocks,
# you can map and filter in a single pass.
exports.For = class For extends While</pre></td><td><pre>      bare = o.level &lt; LEVEL_OP &amp;&amp; (expr instanceof Op || expr instanceof Call || (ex
      if (bare) {
        return code;
      } else {
        return "(" + code + ")";
      }
    };
    return Parens;
  })();
  exports.For = For = (function() {
    __extends(For, While);</pre></td></tr><tr valign="top"><td><pre>1557,1968,body</pre></td><td><pre>  constructor: (body, source) -&gt;
    {@source, @guard, @step, @name, @index} = source
    @body    = Block.wrap [body]</pre></td><td><pre>    function For(body, source) {
      var _ref2;
      this.source = source.source, this.guard = source.guard, this.step = source.step
      this.body = Block.wrap([body]);</pre></td></tr><tr valign="top"><td><pre>1560,1972,own</pre></td><td><pre>    @own     = !!source.own
    @object  = !!source.object</pre></td><td><pre>      this.own = !!source.own;
      this.object = !!source.object;
      if (this.object) {</pre></td></tr><tr valign="top"><td><pre>1562,1975,name</pre></td><td><pre>    [@name, @index] = [@index, @name] if @object
    throw SyntaxError 'index cannot be a pattern matching expression' if @index insta</pre></td><td><pre>        _ref2 = [this.index, this.name], this.name = _ref2[0], this.index = _ref2[1];
      }
      if (this.index instanceof Value) {
        throw SyntaxError('index cannot be a pattern matching expression');
      }</pre></td></tr><tr valign="top"><td><pre>1564,1980,range</pre></td><td><pre>    @range   = @source instanceof Value and @source.base instanceof Range and not @so
    @pattern = @name instanceof Value
    throw SyntaxError 'indexes do not apply to range loops' if @range and @index</pre></td><td><pre>      this.range = this.source instanceof Value &amp;&amp; this.source.base instanceof Range 
      this.pattern = this.name instanceof Value;
      if (this.range &amp;&amp; this.index) {
        throw SyntaxError('indexes do not apply to range loops');
      }
      if (this.range &amp;&amp; this.pattern) {</pre></td></tr><tr valign="top"><td><pre>1567,1986,cannot</pre></td><td><pre>    throw SyntaxError 'cannot pattern match over range loops' if @range and @pattern</pre></td><td><pre>        throw SyntaxError('cannot pattern match over range loops');
      }</pre></td></tr><tr valign="top"><td><pre>1568,1988,returns</pre></td><td><pre>    @returns = false
</pre></td><td><pre>      this.returns = false;
    }</pre></td></tr><tr valign="top"><td><pre>1570,1990,children</pre></td><td><pre>  children: ['body', 'source', 'guard', 'step']

  # Welcome to the hairiest method in all of CoffeeScript. Handles the inner
  # loop, filtering, stepping, and result saving for array, object, and range
  # comprehensions. Some of the generated code can be shared in common, and
  # some cannot.</pre></td><td><pre>    For.prototype.children = ['body', 'source', 'guard', 'step'];</pre></td></tr><tr valign="top"><td><pre>1576,1991,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    For.prototype.compileNode = function(o) {
      var body, defPart, forPart, forVarPart, guardPart, idt1, index, ivar, lastJumps</pre></td></tr><tr valign="top"><td><pre>1577,1993,body</pre></td><td><pre>    body      = Block.wrap [@body]
    lastJumps = last(body.expressions)?.jumps()</pre></td><td><pre>      body = Block.wrap([this.body]);
      lastJumps = (_ref2 = last(body.expressions)) != null ? _ref2.jumps() : void 0;</pre></td></tr><tr valign="top"><td><pre>1579,1995,instanceof</pre></td><td><pre>    @returns  = no if lastJumps and lastJumps instanceof Return</pre></td><td><pre>      if (lastJumps &amp;&amp; lastJumps instanceof Return) {
        this.returns = false;
      }</pre></td></tr><tr valign="top"><td><pre>1580,1998,source</pre></td><td><pre>    source    = if @range then @source.base else @source</pre></td><td><pre>      source = this.range ? this.source.base : this.source;</pre></td></tr><tr valign="top"><td><pre>1581,1999,scope</pre></td><td><pre>    scope     = o.scope</pre></td><td><pre>      scope = o.scope;</pre></td></tr><tr valign="top"><td><pre>1582,2000,name</pre></td><td><pre>    name      = @name  and @name.compile o, LEVEL_LIST
    index     = @index and @index.compile o, LEVEL_LIST
    scope.find(name,  immediate: yes) if name and not @pattern
    scope.find(index, immediate: yes) if index</pre></td><td><pre>      name = this.name &amp;&amp; this.name.compile(o, LEVEL_LIST);
      index = this.index &amp;&amp; this.index.compile(o, LEVEL_LIST);
      if (name &amp;&amp; !this.pattern) {
        scope.find(name, {
          immediate: true
        });
      }
      if (index) {
        scope.find(index, {
          immediate: true
        });
      }</pre></td></tr><tr valign="top"><td><pre>1586,2012,returns</pre></td><td><pre>    rvar      = scope.freeVariable 'results' if @returns</pre></td><td><pre>      if (this.returns) {</pre></td></tr><tr valign="top"><td><pre>1587,2013,scope</pre></td><td><pre>    ivar      = (if @range then name else index) or scope.freeVariable 'i'
    # the `_by` variable is created twice in `Range`s if we don't prevent it from bei
    stepvar   = scope.freeVariable "step" if @step and not @range</pre></td><td><pre>        rvar = scope.freeVariable('results');
      }</pre></td></tr><tr valign="top"><td><pre>1590,2015,name</pre></td><td><pre>    name      = ivar if @pattern</pre></td><td><pre>      ivar = (this.range ? name : index) || scope.freeVariable('i');
      if (this.step &amp;&amp; !this.range) {
        stepvar = scope.freeVariable("step");
      }
      if (this.pattern) {
        name = ivar;
      }</pre></td></tr><tr valign="top"><td><pre>1591,2022,varPart</pre></td><td><pre>    varPart   = ''</pre></td><td><pre>      varPart = '';</pre></td></tr><tr valign="top"><td><pre>1592,2023,guardPart</pre></td><td><pre>    guardPart = ''</pre></td><td><pre>      guardPart = '';</pre></td></tr><tr valign="top"><td><pre>1593,2024,defPart</pre></td><td><pre>    defPart   = ''</pre></td><td><pre>      defPart = '';</pre></td></tr><tr valign="top"><td><pre>1594,2025,idt1</pre></td><td><pre>    idt1      = @tab + TAB</pre></td><td><pre>      idt1 = this.tab + TAB;</pre></td></tr><tr valign="top"><td><pre>1595,2026,range</pre></td><td><pre>    if @range</pre></td><td><pre>      if (this.range) {</pre></td></tr><tr valign="top"><td><pre>1596,2027,forPart</pre></td><td><pre>      forPart = source.compile merge(o, {index: ivar, @step})
    else
      svar    = @source.compile o, LEVEL_LIST</pre></td><td><pre>        forPart = source.compile(merge(o, {
          index: ivar,
          step: this.step
        }));
      } else {
        svar = this.source.compile(o, LEVEL_LIST);</pre></td></tr><tr valign="top"><td><pre>1599,2033,name</pre></td><td><pre>      if (name or @own) and not IDENTIFIER.test svar</pre></td><td><pre>        if ((name || this.own) &amp;&amp; !IDENTIFIER.test(svar)) {</pre></td></tr><tr valign="top"><td><pre>1600,2034,defPart</pre></td><td><pre>        defPart    = "#{@tab}#{ref = scope.freeVariable 'ref'} = #{svar};\n"
        svar       = ref</pre></td><td><pre>          defPart = "" + this.tab + (ref = scope.freeVariable('ref')) + " = " + svar 
          svar = ref;
        }</pre></td></tr><tr valign="top"><td><pre>1602,2037,name</pre></td><td><pre>      if name and not @pattern</pre></td><td><pre>        if (name &amp;&amp; !this.pattern) {</pre></td></tr><tr valign="top"><td><pre>1603,2038,namePart</pre></td><td><pre>        namePart   = "#{name} = #{svar}[#{ivar}]"</pre></td><td><pre>          namePart = "" + name + " = " + svar + "[" + ivar + "]";
        }</pre></td></tr><tr valign="top"><td><pre>1604,2040,object</pre></td><td><pre>      unless @object</pre></td><td><pre>        if (!this.object) {</pre></td></tr><tr valign="top"><td><pre>1605,2041,lvar</pre></td><td><pre>        lvar       = scope.freeVariable 'len'</pre></td><td><pre>          lvar = scope.freeVariable('len');</pre></td></tr><tr valign="top"><td><pre>1606,2042,forVarPart</pre></td><td><pre>        forVarPart = "#{ivar} = 0, #{lvar} = #{svar}.length" + if @step then ", #{ste
        stepPart   = if @step then "#{ivar} += #{stepvar}" else "#{ivar}++"</pre></td><td><pre>          forVarPart = ("" + ivar + " = 0, " + lvar + " = " + svar + ".length") + (th
          stepPart = this.step ? "" + ivar + " += " + stepvar : "" + ivar + "++";</pre></td></tr><tr valign="top"><td><pre>1608,2044,forPart</pre></td><td><pre>        forPart    = "#{forVarPart}; #{ivar} &lt; #{lvar}; #{stepPart}"</pre></td><td><pre>          forPart = "" + forVarPart + "; " + ivar + " &lt; " + lvar + "; " + stepPart;
        }
      }</pre></td></tr><tr valign="top"><td><pre>1609,2047,returns</pre></td><td><pre>    if @returns</pre></td><td><pre>      if (this.returns) {</pre></td></tr><tr valign="top"><td><pre>1610,2048,resultPart</pre></td><td><pre>      resultPart   = "#{@tab}#{rvar} = [];\n"</pre></td><td><pre>        resultPart = "" + this.tab + rvar + " = [];\n";</pre></td></tr><tr valign="top"><td><pre>1611,2049,returnResult</pre></td><td><pre>      returnResult = "\n#{@tab}return #{rvar};"
      body.makeReturn rvar</pre></td><td><pre>        returnResult = "\n" + this.tab + "return " + rvar + ";";
        body.makeReturn(rvar);
      }</pre></td></tr><tr valign="top"><td><pre>1613,2052,guard</pre></td><td><pre>    if @guard</pre></td><td><pre>      if (this.guard) {</pre></td></tr><tr valign="top"><td><pre>1614,2053,body</pre></td><td><pre>      if body.expressions.length &gt; 1
        body.expressions.unshift new If (new Parens @guard).invert(), new Literal "co
      else</pre></td><td><pre>        if (body.expressions.length &gt; 1) {
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Lite
        } else {
          if (this.guard) {</pre></td></tr><tr valign="top"><td><pre>1617,2057,Block</pre></td><td><pre>        body = Block.wrap [new If @guard, body] if @guard</pre></td><td><pre>            body = Block.wrap([new If(this.guard, body)]);
          }
        }
      }</pre></td></tr><tr valign="top"><td><pre>1618,2061,pattern</pre></td><td><pre>    if @pattern</pre></td><td><pre>      if (this.pattern) {</pre></td></tr><tr valign="top"><td><pre>1619,2062,body</pre></td><td><pre>      body.expressions.unshift new Assign @name, new Literal "#{svar}[#{ivar}]"
    defPart     += @pluckDirectCall o, body</pre></td><td><pre>        body.expressions.unshift(new Assign(this.name, new Literal("" + svar + "[" + 
      }
      defPart += this.pluckDirectCall(o, body);
      if (namePart) {</pre></td></tr><tr valign="top"><td><pre>1621,2066,varPart</pre></td><td><pre>    varPart     = "\n#{idt1}#{namePart};" if namePart</pre></td><td><pre>        varPart = "\n" + idt1 + namePart + ";";
      }</pre></td></tr><tr valign="top"><td><pre>1622,2068,object</pre></td><td><pre>    if @object</pre></td><td><pre>      if (this.object) {</pre></td></tr><tr valign="top"><td><pre>1623,2069,forPart</pre></td><td><pre>      forPart   = "#{ivar} in #{svar}"</pre></td><td><pre>        forPart = "" + ivar + " in " + svar;
        if (this.own) {</pre></td></tr><tr valign="top"><td><pre>1624,2071,guardPart</pre></td><td><pre>      guardPart = "\n#{idt1}if (!#{utility 'hasProp'}.call(#{svar}, #{ivar})) continu
    body        = body.compile merge(o, indent: idt1), LEVEL_TOP
    body        = '\n' + body + '\n' if body
    """
    #{defPart}#{resultPart or ''}#{@tab}for (#{forPart}) {#{guardPart}#{varPart}#{bod
    """
</pre></td><td><pre>          guardPart = "\n" + idt1 + "if (!" + (utility('hasProp')) + ".call(" + svar 
        }
      }
      body = body.compile(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      if (body) {
        body = '\n' + body + '\n';
      }
      return "" + defPart + (resultPart || '') + this.tab + "for (" + forPart + ") {"
    };</pre></td></tr><tr valign="top"><td><pre>1631,2082,pluckDirectCall</pre></td><td><pre>  pluckDirectCall: (o, body) -&gt;</pre></td><td><pre>    For.prototype.pluckDirectCall = function(o, body) {
      var base, defs, expr, fn, idx, ref, val, _len, _ref2, _ref3, _ref4, _ref5, _ref</pre></td></tr><tr valign="top"><td><pre>1632,2084,defs</pre></td><td><pre>    defs = ''</pre></td><td><pre>      defs = '';</pre></td></tr><tr valign="top"><td><pre>1633,2085,body</pre></td><td><pre>    for expr, idx in body.expressions</pre></td><td><pre>      _ref2 = body.expressions;
      for (idx = 0, _len = _ref2.length; idx &lt; _len; idx++) {</pre></td></tr><tr valign="top"><td><pre>1634,2087,expr</pre></td><td><pre>      expr = expr.unwrapAll()
      continue unless expr instanceof Call</pre></td><td><pre>        expr = _ref2[idx];</pre></td></tr><tr valign="top"><td><pre>1636,2088,unwrapAll</pre></td><td><pre>      val = expr.variable.unwrapAll()</pre></td><td><pre>        expr = expr.unwrapAll();</pre></td></tr><tr valign="top"><td><pre>1637,2089,instanceof</pre></td><td><pre>      continue unless (val instanceof Code) or
                      (val instanceof Value and</pre></td><td><pre>        if (!(expr instanceof Call)) {
          continue;
        }</pre></td></tr><tr valign="top"><td><pre>1639,2092,unwrapAll</pre></td><td><pre>                      val.base?.unwrapAll() instanceof Code and
                      val.properties.length is 1 and</pre></td><td><pre>        val = expr.variable.unwrapAll();</pre></td></tr><tr valign="top"><td><pre>1641,2093,name</pre></td><td><pre>                      val.properties[0].name?.value in ['call', 'apply'])
      fn    = val.base?.unwrapAll() or val</pre></td><td><pre>        if (!((val instanceof Code) || (val instanceof Value &amp;&amp; ((_ref3 = val.base) !
          continue;
        }
        fn = ((_ref6 = val.base) != null ? _ref6.unwrapAll() : void 0) || val;</pre></td></tr><tr valign="top"><td><pre>1643,2097,ref</pre></td><td><pre>      ref   = new Literal o.scope.freeVariable 'fn'
      base  = new Value ref</pre></td><td><pre>        ref = new Literal(o.scope.freeVariable('fn'));
        base = new Value(ref);</pre></td></tr><tr valign="top"><td><pre>1645,2099,val</pre></td><td><pre>      if val.base
        [val.base, base] = [base, val]</pre></td><td><pre>        if (val.base) {
          _ref7 = [base, val], val.base = _ref7[0], base = _ref7[1];
        }</pre></td></tr><tr valign="top"><td><pre>1647,2102,body</pre></td><td><pre>      body.expressions[idx] = new Call base, expr.args
      defs += @tab + new Assign(ref, fn).compile(o, LEVEL_TOP) + ';\n'
    defs

#### Switch

# A JavaScript *switch* statement. Converts into a returnable expression on-demand.</pre></td><td><pre>        body.expressions[idx] = new Call(base, expr.args);
        defs += this.tab + new Assign(ref, fn).compile(o, LEVEL_TOP) + ';\n';
      }
      return defs;
    };
    return For;
  })();</pre></td></tr><tr valign="top"><td><pre>1654,2109,exports</pre></td><td><pre>exports.Switch = class Switch extends Base</pre></td><td><pre>  exports.Switch = Switch = (function() {
    __extends(Switch, Base);</pre></td></tr><tr valign="top"><td><pre>1655,2111,subject</pre></td><td><pre>  constructor: (@subject, @cases, @otherwise) -&gt;

  children: ['subject', 'cases', 'otherwise']
</pre></td><td><pre>    function Switch(subject, cases, otherwise) {
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
    }
    Switch.prototype.children = ['subject', 'cases', 'otherwise'];</pre></td></tr><tr valign="top"><td><pre>1659,2117,isStatement</pre></td><td><pre>  isStatement: YES
</pre></td><td><pre>    Switch.prototype.isStatement = YES;</pre></td></tr><tr valign="top"><td><pre>1661,2118,jumps</pre></td><td><pre>  jumps: (o = {block: yes}) -&gt;</pre></td><td><pre>    Switch.prototype.jumps = function(o) {
      var block, conds, _i, _len, _ref2, _ref3, _ref4;
      if (o == null) {
        o = {</pre></td></tr><tr valign="top"><td><pre>1662,2122,block</pre></td><td><pre>    for [conds, block] in @cases
      return block if block.jumps o</pre></td><td><pre>          block: true
        };
      }
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        _ref3 = _ref2[_i], conds = _ref3[0], block = _ref3[1];
        if (block.jumps(o)) {
          return block;
        }
      }</pre></td></tr><tr valign="top"><td><pre>1664,2132,otherwise</pre></td><td><pre>    @otherwise?.jumps o
</pre></td><td><pre>      return (_ref4 = this.otherwise) != null ? _ref4.jumps(o) : void 0;
    };</pre></td></tr><tr valign="top"><td><pre>1666,2134,makeReturn</pre></td><td><pre>  makeReturn: (res) -&gt;
    pair[1].makeReturn res for pair in @cases</pre></td><td><pre>    Switch.prototype.makeReturn = function(res) {
      var pair, _i, _len, _ref2, _ref3;
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        pair = _ref2[_i];
        pair[1].makeReturn(res);
      }
      if (res) {</pre></td></tr><tr valign="top"><td><pre>1668,2142,otherwise</pre></td><td><pre>    @otherwise or= new Block [new Literal 'void 0'] if res
    @otherwise?.makeReturn res
    this
</pre></td><td><pre>        this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
      }
      if ((_ref3 = this.otherwise) != null) {
        _ref3.makeReturn(res);
      }
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>1672,2149,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    Switch.prototype.compileNode = function(o) {
      var block, body, code, cond, conditions, expr, i, idt1, idt2, _i, _len, _len2, </pre></td></tr><tr valign="top"><td><pre>1673,2151,idt1</pre></td><td><pre>    idt1 = o.indent + TAB
    idt2 = o.indent = idt1 + TAB</pre></td><td><pre>      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;</pre></td></tr><tr valign="top"><td><pre>1675,2153,code</pre></td><td><pre>    code = @tab + "switch (#{ @subject?.compile(o, LEVEL_PAREN) or false }) {\n"</pre></td><td><pre>      code = this.tab + ("switch (" + (((_ref2 = this.subject) != null ? _ref2.compil</pre></td></tr><tr valign="top"><td><pre>1676,2154,cases</pre></td><td><pre>    for [conditions, block], i in @cases</pre></td><td><pre>      _ref3 = this.cases;
      for (i = 0, _len = _ref3.length; i &lt; _len; i++) {</pre></td></tr><tr valign="top"><td><pre>1677,2156,conditions</pre></td><td><pre>      for cond in flatten [conditions]</pre></td><td><pre>        _ref4 = _ref3[i], conditions = _ref4[0], block = _ref4[1];
        _ref5 = flatten([conditions]);
        for (_i = 0, _len2 = _ref5.length; _i &lt; _len2; _i++) {</pre></td></tr><tr valign="top"><td><pre>1678,2159,cond</pre></td><td><pre>        cond  = cond.invert() unless @subject</pre></td><td><pre>          cond = _ref5[_i];
          if (!this.subject) {
            cond = cond.invert();
          }</pre></td></tr><tr valign="top"><td><pre>1679,2163,code</pre></td><td><pre>        code += idt1 + "case #{ cond.compile o, LEVEL_PAREN }:\n"
      code += body + '\n' if body = block.compile o, LEVEL_TOP</pre></td><td><pre>          code += idt1 + ("case " + (cond.compile(o, LEVEL_PAREN)) + ":\n");
        }
        if (body = block.compile(o, LEVEL_TOP)) {
          code += body + '\n';
        }</pre></td></tr><tr valign="top"><td><pre>1681,2168,cases</pre></td><td><pre>      break if i is @cases.length - 1 and not @otherwise</pre></td><td><pre>        if (i === this.cases.length - 1 &amp;&amp; !this.otherwise) {
          break;
        }</pre></td></tr><tr valign="top"><td><pre>1682,2171,expr</pre></td><td><pre>      expr = @lastNonComment block.expressions
      continue if expr instanceof Return or (expr instanceof Literal and expr.jumps()</pre></td><td><pre>        expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal &amp;&amp; expr.jumps() &amp;&amp; exp
          continue;
        }</pre></td></tr><tr valign="top"><td><pre>1684,2175,code</pre></td><td><pre>      code += idt2 + 'break;\n'
    code += idt1 + "default:\n#{ @otherwise.compile o, LEVEL_TOP }\n" if @otherwise a</pre></td><td><pre>        code += idt2 + 'break;\n';
      }
      if (this.otherwise &amp;&amp; this.otherwise.expressions.length) {
        code += idt1 + ("default:\n" + (this.otherwise.compile(o, LEVEL_TOP)) + "\n")
      }</pre></td></tr><tr valign="top"><td><pre>1686,2180,tab</pre></td><td><pre>    code +  @tab + '}'

#### If

# *If/else* statements. Acts as an expression by pushing down requested returns
# to the last line of each clause.
#
# Single-expression **Ifs** are compiled into conditional operators if possible,
# because ternaries are already proper expressions, and don't need conversion.</pre></td><td><pre>      return code + this.tab + '}';
    };
    return Switch;
  })();</pre></td></tr><tr valign="top"><td><pre>1695,2184,exports</pre></td><td><pre>exports.If = class If extends Base</pre></td><td><pre>  exports.If = If = (function() {
    __extends(If, Base);</pre></td></tr><tr valign="top"><td><pre>1696,2186,condition</pre></td><td><pre>  constructor: (condition, @body, options = {}) -&gt;
    @condition = if options.type is 'unless' then condition.invert() else condition</pre></td><td><pre>    function If(condition, body, options) {
      this.body = body;
      if (options == null) {
        options = {};
      }
      this.condition = options.type === 'unless' ? condition.invert() : condition;</pre></td></tr><tr valign="top"><td><pre>1698,2192,elseBody</pre></td><td><pre>    @elseBody  = null</pre></td><td><pre>      this.elseBody = null;</pre></td></tr><tr valign="top"><td><pre>1699,2193,isChain</pre></td><td><pre>    @isChain   = false</pre></td><td><pre>      this.isChain = false;</pre></td></tr><tr valign="top"><td><pre>1700,2194,soak</pre></td><td><pre>    {@soak}    = options
</pre></td><td><pre>      this.soak = options.soak;
    }</pre></td></tr><tr valign="top"><td><pre>1702,2196,children</pre></td><td><pre>  children: ['condition', 'body', 'elseBody']

  bodyNode:     -&gt; @body?.unwrap()
  elseBodyNode: -&gt; @elseBody?.unwrap()

  # Rewrite a chain of **Ifs** to add a default case as the final *else*.</pre></td><td><pre>    If.prototype.children = ['condition', 'body', 'elseBody'];
    If.prototype.bodyNode = function() {
      var _ref2;
      return (_ref2 = this.body) != null ? _ref2.unwrap() : void 0;
    };
    If.prototype.elseBodyNode = function() {
      var _ref2;
      return (_ref2 = this.elseBody) != null ? _ref2.unwrap() : void 0;
    };</pre></td></tr><tr valign="top"><td><pre>1708,2205,addElse</pre></td><td><pre>  addElse: (elseBody) -&gt;</pre></td><td><pre>    If.prototype.addElse = function(elseBody) {</pre></td></tr><tr valign="top"><td><pre>1709,2206,isChain</pre></td><td><pre>    if @isChain</pre></td><td><pre>      if (this.isChain) {</pre></td></tr><tr valign="top"><td><pre>1710,2207,elseBodyNode</pre></td><td><pre>      @elseBodyNode().addElse elseBody
    else
      @isChain  = elseBody instanceof If</pre></td><td><pre>        this.elseBodyNode().addElse(elseBody);
      } else {
        this.isChain = elseBody instanceof If;</pre></td></tr><tr valign="top"><td><pre>1713,2210,ensureBlock</pre></td><td><pre>      @elseBody = @ensureBlock elseBody
    this

  # The **If** only compiles into a statement if either of its bodies needs
  # to be a statement. Otherwise a conditional operator is safe.</pre></td><td><pre>        this.elseBody = this.ensureBlock(elseBody);
      }
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>1718,2214,isStatement</pre></td><td><pre>  isStatement: (o) -&gt;</pre></td><td><pre>    If.prototype.isStatement = function(o) {
      var _ref2;</pre></td></tr><tr valign="top"><td><pre>1719,2216,level</pre></td><td><pre>    o?.level is LEVEL_TOP or
      @bodyNode().isStatement(o) or @elseBodyNode()?.isStatement(o)
</pre></td><td><pre>      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatem
    };</pre></td></tr><tr valign="top"><td><pre>1722,2218,jumps</pre></td><td><pre>  jumps: (o) -&gt; @body.jumps(o) or @elseBody?.jumps(o)
</pre></td><td><pre>    If.prototype.jumps = function(o) {
      var _ref2;
      return this.body.jumps(o) || ((_ref2 = this.elseBody) != null ? _ref2.jumps(o) 
    };</pre></td></tr><tr valign="top"><td><pre>1724,2222,compileNode</pre></td><td><pre>  compileNode: (o) -&gt;</pre></td><td><pre>    If.prototype.compileNode = function(o) {</pre></td></tr><tr valign="top"><td><pre>1725,2223,isStatement</pre></td><td><pre>    if @isStatement o then @compileStatement o else @compileExpression o
</pre></td><td><pre>      if (this.isStatement(o)) {
        return this.compileStatement(o);
      } else {
        return this.compileExpression(o);
      }
    };</pre></td></tr><tr valign="top"><td><pre>1727,2229,makeReturn</pre></td><td><pre>  makeReturn: (res) -&gt;
    @elseBody  or= new Block [new Literal 'void 0'] if res
    @body     and= new Block [@body.makeReturn res]
    @elseBody and= new Block [@elseBody.makeReturn res]
    this
</pre></td><td><pre>    If.prototype.makeReturn = function(res) {
      if (res) {
        this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
      }
      this.body &amp;&amp; (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody &amp;&amp; (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
    };</pre></td></tr><tr valign="top"><td><pre>1733,2237,ensureBlock</pre></td><td><pre>  ensureBlock: (node) -&gt;
    if node instanceof Block then node else new Block [node]

  # Compile the `If` as a regular *if-else* statement. Flattened chains
  # force inner *else* bodies into statement form.</pre></td><td><pre>    If.prototype.ensureBlock = function(node) {
      if (node instanceof Block) {
        return node;
      } else {
        return new Block([node]);
      }
    };</pre></td></tr><tr valign="top"><td><pre>1738,2244,compileStatement</pre></td><td><pre>  compileStatement: (o) -&gt;</pre></td><td><pre>    If.prototype.compileStatement = function(o) {
      var body, bodyc, child, cond, exeq, ifPart, _ref2;</pre></td></tr><tr valign="top"><td><pre>1739,2246,child</pre></td><td><pre>    child    = del o, 'chainChild'
    exeq     = del o, 'isExistentialEquals'

    if exeq</pre></td><td><pre>      child = del(o, 'chainChild');
      exeq = del(o, 'isExistentialEquals');
      if (exeq) {</pre></td></tr><tr valign="top"><td><pre>1743,2249,new</pre></td><td><pre>      return new If(@condition.invert(), @elseBodyNode(), type: 'if').compile o

    cond     = @condition.compile o, LEVEL_PAREN</pre></td><td><pre>        return new If(this.condition.invert(), this.elseBodyNode(), {
          type: 'if'
        }).compile(o);
      }
      cond = this.condition.compile(o, LEVEL_PAREN);</pre></td></tr><tr valign="top"><td><pre>1746,2254,indent</pre></td><td><pre>    o.indent += TAB</pre></td><td><pre>      o.indent += TAB;</pre></td></tr><tr valign="top"><td><pre>1747,2255,body</pre></td><td><pre>    body     = @ensureBlock(@body)
    bodyc    = body.compile o
    if (</pre></td><td><pre>      body = this.ensureBlock(this.body);
      bodyc = body.compile(o);</pre></td></tr><tr valign="top"><td><pre>1750,2257,expressions</pre></td><td><pre>      1 is body.expressions?.length and
      !@elseBody and !child and
      bodyc and cond and
      -1 is (bodyc.indexOf '\n') and
      80 &gt; cond.length + bodyc.length
    )
      return "#{@tab}if (#{cond}) #{bodyc.replace /^\s+/, ''}"
    bodyc    = "\n#{bodyc}\n#{@tab}" if bodyc</pre></td><td><pre>      if (1 === ((_ref2 = body.expressions) != null ? _ref2.length : void 0) &amp;&amp; !this
        return "" + this.tab + "if (" + cond + ") " + (bodyc.replace(/^\s+/, ''));
      }
      if (bodyc) {
        bodyc = "\n" + bodyc + "\n" + this.tab;
      }</pre></td></tr><tr valign="top"><td><pre>1758,2263,ifPart</pre></td><td><pre>    ifPart   = "if (#{cond}) {#{bodyc}}"
    ifPart   = @tab + ifPart unless child</pre></td><td><pre>      ifPart = "if (" + cond + ") {" + bodyc + "}";
      if (!child) {
        ifPart = this.tab + ifPart;
      }</pre></td></tr><tr valign="top"><td><pre>1760,2267,elseBody</pre></td><td><pre>    return ifPart unless @elseBody</pre></td><td><pre>      if (!this.elseBody) {</pre></td></tr><tr valign="top"><td><pre>1761,2268,ifPart</pre></td><td><pre>    ifPart + ' else ' + if @isChain</pre></td><td><pre>        return ifPart;
      }</pre></td></tr><tr valign="top"><td><pre>1762,2270,indent</pre></td><td><pre>      o.indent = @tab
      o.chainChild = yes
      @elseBody.unwrap().compile o, LEVEL_TOP
    else
      "{\n#{ @elseBody.compile o, LEVEL_TOP }\n#{@tab}}"

  # Compile the `If` as a conditional operator.</pre></td><td><pre>      return ifPart + ' else ' + (this.isChain ? (o.indent = this.tab, o.chainChild =
    };</pre></td></tr><tr valign="top"><td><pre>1769,2272,compileExpression</pre></td><td><pre>  compileExpression: (o) -&gt;</pre></td><td><pre>    If.prototype.compileExpression = function(o) {
      var alt, body, code, cond;</pre></td></tr><tr valign="top"><td><pre>1770,2274,cond</pre></td><td><pre>    cond = @condition.compile o, LEVEL_COND
    body = @bodyNode().compile o, LEVEL_LIST</pre></td><td><pre>      cond = this.condition.compile(o, LEVEL_COND);
      body = this.bodyNode().compile(o, LEVEL_LIST);</pre></td></tr><tr valign="top"><td><pre>1772,2276,alt</pre></td><td><pre>    alt  = if @elseBodyNode() then @elseBodyNode().compile(o, LEVEL_LIST) else 'void </pre></td><td><pre>      alt = this.elseBodyNode() ? this.elseBodyNode().compile(o, LEVEL_LIST) : 'void </pre></td></tr><tr valign="top"><td><pre>1773,2277,code</pre></td><td><pre>    code = "#{cond} ? #{body} : #{alt}"</pre></td><td><pre>      code = "" + cond + " ? " + body + " : " + alt;</pre></td></tr><tr valign="top"><td><pre>1774,2278,level</pre></td><td><pre>    if o.level &gt;= LEVEL_COND then "(#{code})" else code
</pre></td><td><pre>      if (o.level &gt;= LEVEL_COND) {
        return "(" + code + ")";
      } else {
        return code;
      }
    };</pre></td></tr><tr valign="top"><td><pre>1776,2284,unfoldSoak</pre></td><td><pre>  unfoldSoak: -&gt;</pre></td><td><pre>    If.prototype.unfoldSoak = function() {</pre></td></tr><tr valign="top"><td><pre>1777,2285,soak</pre></td><td><pre>    @soak and this

# Faux-Nodes
# ----------
# Faux-nodes are never created by the grammar, but are used during code
# generation to generate other combinations of nodes.

#### Closure

# A faux-node used to wrap an expressions body in a closure.</pre></td><td><pre>      return this.soak &amp;&amp; this;
    };
    return If;
  })();</pre></td></tr><tr valign="top"><td><pre>1787,2289,Closure</pre></td><td><pre>Closure =

  # Wrap the expressions body, unless it contains a pure statement,
  # in which case, no dice. If the body mentions `this` or `arguments`,
  # then make sure that the closure wrapper preserves the original values.</pre></td><td><pre>  Closure = {</pre></td></tr><tr valign="top"><td><pre>1792,2290,wrap</pre></td><td><pre>  wrap: (expressions, statement, noReturn) -&gt;
    return expressions if expressions.jumps()
    func = new Code [], Block.wrap [expressions]</pre></td><td><pre>    wrap: function(expressions, statement, noReturn) {
      var args, call, func, mentionsArgs, meth;
      if (expressions.jumps()) {
        return expressions;
      }
      func = new Code([], Block.wrap([expressions]));</pre></td></tr><tr valign="top"><td><pre>1795,2296,args</pre></td><td><pre>    args = []</pre></td><td><pre>      args = [];</pre></td></tr><tr valign="top"><td><pre>1796,2297,mentionsArgs</pre></td><td><pre>    if (mentionsArgs = expressions.contains @literalArgs) or expressions.contains @li
      meth = new Literal if mentionsArgs then 'apply' else 'call'</pre></td><td><pre>      if ((mentionsArgs = expressions.contains(this.literalArgs)) || expressions.cont
        meth = new Literal(mentionsArgs ? 'apply' : 'call');</pre></td></tr><tr valign="top"><td><pre>1798,2299,args</pre></td><td><pre>      args = [new Literal 'this']
      args.push new Literal 'arguments' if mentionsArgs</pre></td><td><pre>        args = [new Literal('this')];
        if (mentionsArgs) {
          args.push(new Literal('arguments'));
        }</pre></td></tr><tr valign="top"><td><pre>1800,2303,func</pre></td><td><pre>      func = new Value func, [new Access meth]
    func.noReturn = noReturn
    call = new Call func, args</pre></td><td><pre>        func = new Value(func, [new Access(meth)]);
      }
      func.noReturn = noReturn;
      call = new Call(func, args);</pre></td></tr><tr valign="top"><td><pre>1803,2307,statement</pre></td><td><pre>    if statement then Block.wrap [call] else call
</pre></td><td><pre>      if (statement) {
        return Block.wrap([call]);
      } else {
        return call;
      }
    },</pre></td></tr><tr valign="top"><td><pre>1805,2313,literalArgs</pre></td><td><pre>  literalArgs: (node) -&gt;
    node instanceof Literal and node.value is 'arguments' and not node.asKey</pre></td><td><pre>    literalArgs: function(node) {
      return node instanceof Literal &amp;&amp; node.value === 'arguments' &amp;&amp; !node.asKey;
    },</pre></td></tr><tr valign="top"><td><pre>1807,2316,literalThis</pre></td><td><pre>  literalThis: (node) -&gt;
    (node instanceof Literal and node.value is 'this' and not node.asKey) or</pre></td><td><pre>    literalThis: function(node) {</pre></td></tr><tr valign="top"><td><pre>1809,2317,Code</pre></td><td><pre>      (node instanceof Code and node.bound)

# Unfold a node's child if soak, then tuck the node under created `If`</pre></td><td><pre>      return (node instanceof Literal &amp;&amp; node.value === 'this' &amp;&amp; !node.asKey) || (no
    }
  };</pre></td></tr><tr valign="top"><td><pre>1812,2320,unfoldSoak</pre></td><td><pre>unfoldSoak = (o, parent, name) -&gt;
  return unless ifn = parent[name].unfoldSoak o</pre></td><td><pre>  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }</pre></td></tr><tr valign="top"><td><pre>1814,2325,body</pre></td><td><pre>  parent[name] = ifn.body
  ifn.body = new Value parent
  ifn

# Constants
# ---------
</pre></td><td><pre>    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };</pre></td></tr><tr valign="top"><td><pre>1821,2329,UTILITIES</pre></td><td><pre>UTILITIES =

  # Correctly set up a prototype chain for inheritance, including a reference
  # to the superclass for `super()` calls, and copies of any static properties.</pre></td><td><pre>  UTILITIES = {</pre></td></tr><tr valign="top"><td><pre>1825,2330,extends</pre></td><td><pre>  extends: -&gt; """
    function(child, parent) { for (var key in parent) { if (#{utility 'hasProp'}.call
  """

  # Create a function bound to the current value of "this".</pre></td><td><pre>    "extends": function() {
      return "function(child, parent) { for (var key in parent) { if (" + (utility('h
    },</pre></td></tr><tr valign="top"><td><pre>1830,2333,bind</pre></td><td><pre>  bind: -&gt; '''
    function(fn, me){ return function(){ return fn.apply(me, arguments); }; }
  '''

  # Discover if an item is in an array.</pre></td><td><pre>    bind: function() {
      return 'function(fn, me){ return function(){ return fn.apply(me, arguments); };
    },</pre></td></tr><tr valign="top"><td><pre>1835,2336,indexOf</pre></td><td><pre>  indexOf: -&gt; """
    Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i &lt; 
  """

  # Shortcuts to speed up the lookup time for native functions.</pre></td><td><pre>    indexOf: function() {</pre></td></tr><tr valign="top"><td><pre>1840,2337,hasProp</pre></td><td><pre>  hasProp: -&gt; 'Object.prototype.hasOwnProperty'
  slice  : -&gt; 'Array.prototype.slice'

# Levels indicate a node's position in the AST. Useful for knowing if
# parens are necessary or superfluous.</pre></td><td><pre>      return "Array.prototype.indexOf || function(item) { for (var i = 0, l = this.le
    },
    hasProp: function() {
      return 'Object.prototype.hasOwnProperty';
    },
    slice: function() {
      return 'Array.prototype.slice';
    }
  };</pre></td></tr><tr valign="top"><td><pre>1845,2346,LEVEL_TOP</pre></td><td><pre>LEVEL_TOP    = 1  # ...;</pre></td><td><pre>  LEVEL_TOP = 1;</pre></td></tr><tr valign="top"><td><pre>1846,2347,LEVEL_PAREN</pre></td><td><pre>LEVEL_PAREN  = 2  # (...)</pre></td><td><pre>  LEVEL_PAREN = 2;</pre></td></tr><tr valign="top"><td><pre>1847,2348,LEVEL_LIST</pre></td><td><pre>LEVEL_LIST   = 3  # [...]</pre></td><td><pre>  LEVEL_LIST = 3;</pre></td></tr><tr valign="top"><td><pre>1848,2349,LEVEL_COND</pre></td><td><pre>LEVEL_COND   = 4  # ... ? x : y</pre></td><td><pre>  LEVEL_COND = 4;</pre></td></tr><tr valign="top"><td><pre>1849,2350,LEVEL_OP</pre></td><td><pre>LEVEL_OP     = 5  # !...</pre></td><td><pre>  LEVEL_OP = 5;</pre></td></tr><tr valign="top"><td><pre>1850,2351,LEVEL_ACCESS</pre></td><td><pre>LEVEL_ACCESS = 6  # ...[0]

# Tabs are two spaces for pretty printing.</pre></td><td><pre>  LEVEL_ACCESS = 6;</pre></td></tr><tr valign="top"><td><pre>1853,2352,TAB</pre></td><td><pre>TAB = '  '
</pre></td><td><pre>  TAB = '  ';</pre></td></tr><tr valign="top"><td><pre>1855,2353,IDENTIFIER_STR</pre></td><td><pre>IDENTIFIER_STR = "[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*"</pre></td><td><pre>  IDENTIFIER_STR = "[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*";</pre></td></tr><tr valign="top"><td><pre>1856,2354,IDENTIFIER</pre></td><td><pre>IDENTIFIER = /// ^ #{IDENTIFIER_STR} $ ///</pre></td><td><pre>  IDENTIFIER = RegExp("^" + IDENTIFIER_STR + "$");</pre></td></tr><tr valign="top"><td><pre>1857,2355,SIMPLENUM</pre></td><td><pre>SIMPLENUM  = /^[+-]?\d+$/</pre></td><td><pre>  SIMPLENUM = /^[+-]?\d+$/;</pre></td></tr><tr valign="top"><td><pre>1858,2356,METHOD_DEF</pre></td><td><pre>METHOD_DEF = ///
  ^
    (?:
      (#{IDENTIFIER_STR})
      \.prototype
      (?:
        \.(#{IDENTIFIER_STR})
      | \[("(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*')\]
      | \[(0x[\da-fA-F]+ | \d*\.?\d+ (?:[eE][+-]?\d+)?)\]
      )
    )
  |
    (#{IDENTIFIER_STR})
  $
///

# Is a literal value a string?</pre></td><td><pre>  METHOD_DEF = RegExp("^(?:(" + IDENTIFIER_STR + ")\\.prototype(?:\\.(" + IDENTIFIER_</pre></td></tr><tr valign="top"><td><pre>1875,2357,IS_STRING</pre></td><td><pre>IS_STRING = /^['"]/

# Utility Functions
# -----------------

# Helper for ensuring that utility functions are assigned at the top level.</pre></td><td><pre>  IS_STRING = /^['"]/;</pre></td></tr><tr valign="top"><td><pre>1881,2358,utility</pre></td><td><pre>utility = (name) -&gt;</pre></td><td><pre>  utility = function(name) {
    var ref;</pre></td></tr><tr valign="top"><td><pre>1882,2360,ref</pre></td><td><pre>  ref = "__#{name}"
  Scope.root.assign ref, UTILITIES[name]()
  ref
</pre></td><td><pre>    ref = "__" + name;
    Scope.root.assign(ref, UTILITIES[name]());
    return ref;
  };</pre></td></tr><tr valign="top"><td><pre>1886,2364,multident</pre></td><td><pre>multident = (code, tab) -&gt;
  code = code.replace /\n/g, '$&amp;' + tab
  code.replace /\s+$/, ''
</pre></td><td><pre>  multident = function(code, tab) {
    code = code.replace(/\n/g, '$&amp;' + tab);
    return code.replace(/\s+$/, '');
  };
}).call(this);
</pre></td></tr></table>
